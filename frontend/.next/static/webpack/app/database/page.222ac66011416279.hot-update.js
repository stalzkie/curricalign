"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/database/page",{

/***/ "(app-pages-browser)/./src/lib/databaseService.ts":
/*!************************************!*\
  !*** ./src/lib/databaseService.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchTableRows: () => (/* binding */ fetchTableRows),\n/* harmony export */   getDbRowsCached: () => (/* binding */ getDbRowsCached),\n/* harmony export */   getDbRowsFresh: () => (/* binding */ getDbRowsFresh),\n/* harmony export */   getTableLastChanged: () => (/* binding */ getTableLastChanged),\n/* harmony export */   invalidateDbCache: () => (/* binding */ invalidateDbCache),\n/* harmony export */   invalidateManyDbCaches: () => (/* binding */ invalidateManyDbCaches)\n/* harmony export */ });\n/* harmony import */ var _lib_supabaseClients__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabaseClients */ \"(app-pages-browser)/./src/lib/supabaseClients.ts\");\n/* harmony import */ var _dataCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataCache */ \"(app-pages-browser)/./src/lib/dataCache.ts\");\n// src/lib/databaseService.ts\n\n\nconst CK = (table)=>\"db:\".concat(table);\n/** Utility: stringify any unknown error safely */ function toErrMessage(err) {\n    if (err instanceof Error) return err.message;\n    try {\n        return typeof err === \"string\" ? err : JSON.stringify(err !== null && err !== void 0 ? err : {});\n    } catch (e) {\n        return String(err);\n    }\n}\n/** Utility: ensure a clean, unique list of valid column names */ function sanitizeColumns(cols) {\n    const out = (cols !== null && cols !== void 0 ? cols : []).filter((c)=>typeof c === \"string\" && c.trim().length > 0).map((c)=>c.trim());\n    // remove duplicates while preserving order\n    return Array.from(new Set(out));\n}\n/** Fetch the change-version (updated_at) for a table from public.table_versions. */ async function getTableLastChanged(table) {\n    try {\n        const { data, error } = await _lib_supabaseClients__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"table_versions\").select(\"updated_at\").eq(\"table_name\", table).maybeSingle();\n        if (error) {\n            // Wrap as real Error so callers see the details\n            throw new Error(JSON.stringify({\n                where: \"getTableLastChanged\",\n                table,\n                message: error.message,\n                details: error.details,\n                hint: error.hint,\n                code: error.code\n            }, null, 2));\n        }\n        // If the row isn't there yet, treat as \"ancient\" so first fetch proceeds and seeds cache\n        const iso = (data === null || data === void 0 ? void 0 : data.updated_at) ? new Date(data.updated_at).toISOString() : new Date(0).toISOString();\n        return iso;\n    } catch (e) {\n        // Re-throw as an Error if something odd was thrown\n        throw new Error(toErrMessage(e));\n    }\n}\n/**\n * Fetch rows from a table with a projection (columns list).\n * Optionally supports range() for simple pagination.\n */ async function fetchTableRows(table, columns, opts) {\n    const cleaned = sanitizeColumns(columns);\n    const selectCols = cleaned.length ? cleaned.join(\",\") : \"*\";\n    // Helpful debug to see exactly what we’re querying\n    // (You can mute this later.)\n    // eslint-disable-next-line no-console\n    console.info(\"[databaseService] select \".concat(table, \" ->\"), selectCols);\n    try {\n        let q = _lib_supabaseClients__WEBPACK_IMPORTED_MODULE_0__.supabase.from(table).select(selectCols);\n        if (typeof (opts === null || opts === void 0 ? void 0 : opts.from) === \"number\" && typeof (opts === null || opts === void 0 ? void 0 : opts.to) === \"number\") {\n            q = q.range(opts.from, opts.to);\n        }\n        const { data, error } = await q;\n        if (error) {\n            // Wrap as Error so React overlay shows message instead of \"{}\"\n            throw new Error(JSON.stringify({\n                where: \"fetchTableRows\",\n                table,\n                select: selectCols,\n                message: error.message,\n                details: error.details,\n                hint: error.hint,\n                code: error.code\n            }, null, 2));\n        }\n        return data !== null && data !== void 0 ? data : [];\n    } catch (e) {\n        // Re-wrap unknown throws\n        throw new Error(toErrMessage(e));\n    }\n}\n/**\n * Version-gated cached fetch.\n * - Reads version from table_versions\n * - Returns cached rows if version unchanged\n * - Otherwise fetches rows and caches them with setCache\n *\n * @param table Supabase table name (e.g., \"course_alignment_scores_clean\")\n * @param columns Columns to select (keep this tight for performance)\n * @param opts Optional paging + stale behavior\n */ async function getDbRowsCached(table, columns, opts) {\n    const cacheKey = CK(table);\n    var _opts_allowStaleOnVersionError;\n    const allowStale = (_opts_allowStaleOnVersionError = opts === null || opts === void 0 ? void 0 : opts.allowStaleOnVersionError) !== null && _opts_allowStaleOnVersionError !== void 0 ? _opts_allowStaleOnVersionError : true;\n    // 1) Read current lastChanged from DB\n    let lastChanged = null;\n    try {\n        lastChanged = await getTableLastChanged(table);\n    } catch (err) {\n        // Version check failed (missing table_versions or RLS). Optionally serve stale.\n        if (!allowStale) throw new Error(toErrMessage(err));\n        const cachedRaw = safeReadCache(cacheKey);\n        if (cachedRaw) return cachedRaw.data;\n    // Fall through to a direct fetch so UI isn’t stuck\n    }\n    // 2) If we have cache and versions match → return cached\n    const cached = safeReadCache(cacheKey);\n    if (lastChanged && (cached === null || cached === void 0 ? void 0 : cached.lastChanged) === lastChanged) {\n        return cached.data;\n    }\n    // 3) Fetch fresh rows\n    const rows = await fetchTableRows(table, columns, {\n        from: opts === null || opts === void 0 ? void 0 : opts.from,\n        to: opts === null || opts === void 0 ? void 0 : opts.to\n    });\n    // 4) Save cache (also BroadcastChannel invalidation to other tabs via setCache)\n    const finalLastChanged = lastChanged !== null && lastChanged !== void 0 ? lastChanged : new Date().toISOString();\n    (0,_dataCache__WEBPACK_IMPORTED_MODULE_1__.setCache)(cacheKey, rows, finalLastChanged);\n    return rows;\n}\n/**\n * Always fetch fresh (ignores local cache) and then refresh the cache with the\n * latest version from table_versions if available.\n */ async function getDbRowsFresh(table, columns, opts) {\n    const cacheKey = CK(table);\n    const rows = await fetchTableRows(table, columns, {\n        from: opts === null || opts === void 0 ? void 0 : opts.from,\n        to: opts === null || opts === void 0 ? void 0 : opts.to\n    });\n    let lastChanged = new Date().toISOString();\n    try {\n        lastChanged = await getTableLastChanged(table);\n    } catch (e) {\n    // ignore version errors; still cache with now()\n    }\n    (0,_dataCache__WEBPACK_IMPORTED_MODULE_1__.setCache)(cacheKey, rows, lastChanged);\n    return rows;\n}\n/** Manually invalidate one table’s cache (and notify other tabs). */ function invalidateDbCache(table) {\n    (0,_dataCache__WEBPACK_IMPORTED_MODULE_1__.clearCache)(CK(table));\n}\n/** Bulk invalidate multiple tables. */ function invalidateManyDbCaches(tables) {\n    for (const t of tables)(0,_dataCache__WEBPACK_IMPORTED_MODULE_1__.clearCache)(CK(t));\n}\n/** Utility: safe read of your cache entry from localStorage (mirrors dataCache’s storage). */ function safeReadCache(key) {\n    try {\n        const raw = localStorage.getItem(key);\n        if (!raw) return null;\n        return JSON.parse(raw);\n    } catch (e) {\n        return null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGF0YWJhc2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQ29CO0FBQ0U7QUFRbkQsTUFBTUcsS0FBSyxDQUFDQyxRQUFrQixNQUFZLE9BQU5BO0FBRXBDLGdEQUFnRCxHQUNoRCxTQUFTQyxhQUFhQyxHQUFZO0lBQ2hDLElBQUlBLGVBQWVDLE9BQU8sT0FBT0QsSUFBSUUsT0FBTztJQUM1QyxJQUFJO1FBQ0YsT0FBTyxPQUFPRixRQUFRLFdBQVdBLE1BQU1HLEtBQUtDLFNBQVMsQ0FBQ0osZ0JBQUFBLGlCQUFBQSxNQUFPLENBQUM7SUFDaEUsRUFBRSxVQUFNO1FBQ04sT0FBT0ssT0FBT0w7SUFDaEI7QUFDRjtBQUVBLCtEQUErRCxHQUMvRCxTQUFTTSxnQkFBZ0JDLElBQWU7SUFDdEMsTUFBTUMsTUFBTSxDQUFDRCxpQkFBQUEsa0JBQUFBLE9BQVEsRUFBRSxFQUNwQkUsTUFBTSxDQUFDLENBQUNDLElBQW1CLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUMsSUFBSSxHQUFHQyxNQUFNLEdBQUcsR0FDdEVDLEdBQUcsQ0FBQyxDQUFDSCxJQUFNQSxFQUFFQyxJQUFJO0lBQ3BCLDJDQUEyQztJQUMzQyxPQUFPRyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSVI7QUFDNUI7QUFFQSxrRkFBa0YsR0FDM0UsZUFBZVMsb0JBQW9CbkIsS0FBYTtJQUNyRCxJQUFJO1FBQ0YsTUFBTSxFQUFFb0IsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNekIsMERBQVFBLENBQ25DcUIsSUFBSSxDQUFDLGtCQUNMSyxNQUFNLENBQUMsY0FDUEMsRUFBRSxDQUFDLGNBQWN2QixPQUNqQndCLFdBQVc7UUFFZCxJQUFJSCxPQUFPO1lBQ1QsZ0RBQWdEO1lBQ2hELE1BQU0sSUFBSWxCLE1BQ1JFLEtBQUtDLFNBQVMsQ0FDWjtnQkFBRW1CLE9BQU87Z0JBQXVCekI7Z0JBQU9JLFNBQVNpQixN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Q1Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3N0YWwvRG9jdW1lbnRzL1Byb2plY3RzL2N1cnJpY2FsaWduL2Zyb250ZW5kL3NyYy9saWIvZGF0YWJhc2VTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvZGF0YWJhc2VTZXJ2aWNlLnRzXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gXCJAL2xpYi9zdXBhYmFzZUNsaWVudHNcIjtcbmltcG9ydCB7IHNldENhY2hlLCBjbGVhckNhY2hlIH0gZnJvbSBcIi4vZGF0YUNhY2hlXCI7XG5cbmV4cG9ydCB0eXBlIERiQ2FjaGVFbnRyeTxUID0gYW55PiA9IHtcbiAgZGF0YTogVFtdO1xuICBsYXN0Q2hhbmdlZDogc3RyaW5nOyAvLyBJU08gd2hlbiB0aGUgdGFibGUgbGFzdCBjaGFuZ2VkIChmcm9tIHRhYmxlX3ZlcnNpb25zLnVwZGF0ZWRfYXQpXG4gIGNhY2hlZEF0OiBzdHJpbmc7ICAgIC8vIElTTyB3aGVuIHdlIGNhY2hlZCBsb2NhbGx5XG59O1xuXG5jb25zdCBDSyA9ICh0YWJsZTogc3RyaW5nKSA9PiBgZGI6JHt0YWJsZX1gO1xuXG4vKiogVXRpbGl0eTogc3RyaW5naWZ5IGFueSB1bmtub3duIGVycm9yIHNhZmVseSAqL1xuZnVuY3Rpb24gdG9FcnJNZXNzYWdlKGVycjogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIGVyci5tZXNzYWdlO1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiID8gZXJyIDogSlNPTi5zdHJpbmdpZnkoZXJyID8/IHt9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFN0cmluZyhlcnIpO1xuICB9XG59XG5cbi8qKiBVdGlsaXR5OiBlbnN1cmUgYSBjbGVhbiwgdW5pcXVlIGxpc3Qgb2YgdmFsaWQgY29sdW1uIG5hbWVzICovXG5mdW5jdGlvbiBzYW5pdGl6ZUNvbHVtbnMoY29scz86IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBvdXQgPSAoY29scyA/PyBbXSlcbiAgICAuZmlsdGVyKChjKTogYyBpcyBzdHJpbmcgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgJiYgYy50cmltKCkubGVuZ3RoID4gMClcbiAgICAubWFwKChjKSA9PiBjLnRyaW0oKSk7XG4gIC8vIHJlbW92ZSBkdXBsaWNhdGVzIHdoaWxlIHByZXNlcnZpbmcgb3JkZXJcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvdXQpKTtcbn1cblxuLyoqIEZldGNoIHRoZSBjaGFuZ2UtdmVyc2lvbiAodXBkYXRlZF9hdCkgZm9yIGEgdGFibGUgZnJvbSBwdWJsaWMudGFibGVfdmVyc2lvbnMuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFibGVMYXN0Q2hhbmdlZCh0YWJsZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJ0YWJsZV92ZXJzaW9uc1wiKVxuICAgICAgLnNlbGVjdChcInVwZGF0ZWRfYXRcIilcbiAgICAgIC5lcShcInRhYmxlX25hbWVcIiwgdGFibGUpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgLy8gV3JhcCBhcyByZWFsIEVycm9yIHNvIGNhbGxlcnMgc2VlIHRoZSBkZXRhaWxzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgd2hlcmU6IFwiZ2V0VGFibGVMYXN0Q2hhbmdlZFwiLCB0YWJsZSwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgZGV0YWlsczogZXJyb3IuZGV0YWlscywgaGludDogZXJyb3IuaGludCwgY29kZTogZXJyb3IuY29kZSB9LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgMlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByb3cgaXNuJ3QgdGhlcmUgeWV0LCB0cmVhdCBhcyBcImFuY2llbnRcIiBzbyBmaXJzdCBmZXRjaCBwcm9jZWVkcyBhbmQgc2VlZHMgY2FjaGVcbiAgICBjb25zdCBpc28gPSBkYXRhPy51cGRhdGVkX2F0ID8gbmV3IERhdGUoZGF0YS51cGRhdGVkX2F0KS50b0lTT1N0cmluZygpIDogbmV3IERhdGUoMCkudG9JU09TdHJpbmcoKTtcbiAgICByZXR1cm4gaXNvO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUmUtdGhyb3cgYXMgYW4gRXJyb3IgaWYgc29tZXRoaW5nIG9kZCB3YXMgdGhyb3duXG4gICAgdGhyb3cgbmV3IEVycm9yKHRvRXJyTWVzc2FnZShlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCByb3dzIGZyb20gYSB0YWJsZSB3aXRoIGEgcHJvamVjdGlvbiAoY29sdW1ucyBsaXN0KS5cbiAqIE9wdGlvbmFsbHkgc3VwcG9ydHMgcmFuZ2UoKSBmb3Igc2ltcGxlIHBhZ2luYXRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRhYmxlUm93czxUID0gYW55PihcbiAgdGFibGU6IHN0cmluZyxcbiAgY29sdW1uczogc3RyaW5nW10sXG4gIG9wdHM/OiB7IGZyb20/OiBudW1iZXI7IHRvPzogbnVtYmVyIH1cbik6IFByb21pc2U8VFtdPiB7XG4gIGNvbnN0IGNsZWFuZWQgPSBzYW5pdGl6ZUNvbHVtbnMoY29sdW1ucyk7XG4gIGNvbnN0IHNlbGVjdENvbHMgPSBjbGVhbmVkLmxlbmd0aCA/IGNsZWFuZWQuam9pbihcIixcIikgOiBcIipcIjtcblxuICAvLyBIZWxwZnVsIGRlYnVnIHRvIHNlZSBleGFjdGx5IHdoYXQgd2XigJlyZSBxdWVyeWluZ1xuICAvLyAoWW91IGNhbiBtdXRlIHRoaXMgbGF0ZXIuKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmluZm8oYFtkYXRhYmFzZVNlcnZpY2VdIHNlbGVjdCAke3RhYmxlfSAtPmAsIHNlbGVjdENvbHMpO1xuXG4gIHRyeSB7XG4gICAgbGV0IHEgPSBzdXBhYmFzZS5mcm9tKHRhYmxlKS5zZWxlY3Qoc2VsZWN0Q29scyk7XG5cbiAgICBpZiAodHlwZW9mIG9wdHM/LmZyb20gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG9wdHM/LnRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBxID0gcS5yYW5nZShvcHRzLmZyb20sIG9wdHMudG8pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHE7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIFdyYXAgYXMgRXJyb3Igc28gUmVhY3Qgb3ZlcmxheSBzaG93cyBtZXNzYWdlIGluc3RlYWQgb2YgXCJ7fVwiXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgd2hlcmU6IFwiZmV0Y2hUYWJsZVJvd3NcIiwgdGFibGUsIHNlbGVjdDogc2VsZWN0Q29scywgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgZGV0YWlsczogZXJyb3IuZGV0YWlscywgaGludDogZXJyb3IuaGludCwgY29kZTogZXJyb3IuY29kZSB9LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgMlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEgPz8gW10pIGFzIFRbXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFJlLXdyYXAgdW5rbm93biB0aHJvd3NcbiAgICB0aHJvdyBuZXcgRXJyb3IodG9FcnJNZXNzYWdlKGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb24tZ2F0ZWQgY2FjaGVkIGZldGNoLlxuICogLSBSZWFkcyB2ZXJzaW9uIGZyb20gdGFibGVfdmVyc2lvbnNcbiAqIC0gUmV0dXJucyBjYWNoZWQgcm93cyBpZiB2ZXJzaW9uIHVuY2hhbmdlZFxuICogLSBPdGhlcndpc2UgZmV0Y2hlcyByb3dzIGFuZCBjYWNoZXMgdGhlbSB3aXRoIHNldENhY2hlXG4gKlxuICogQHBhcmFtIHRhYmxlIFN1cGFiYXNlIHRhYmxlIG5hbWUgKGUuZy4sIFwiY291cnNlX2FsaWdubWVudF9zY29yZXNfY2xlYW5cIilcbiAqIEBwYXJhbSBjb2x1bW5zIENvbHVtbnMgdG8gc2VsZWN0IChrZWVwIHRoaXMgdGlnaHQgZm9yIHBlcmZvcm1hbmNlKVxuICogQHBhcmFtIG9wdHMgT3B0aW9uYWwgcGFnaW5nICsgc3RhbGUgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERiUm93c0NhY2hlZDxUID0gYW55PihcbiAgdGFibGU6IHN0cmluZyxcbiAgY29sdW1uczogc3RyaW5nW10sXG4gIG9wdHM/OiB7XG4gICAgZnJvbT86IG51bWJlcjtcbiAgICB0bz86IG51bWJlcjtcbiAgICAvKiogQWxsb3cgcmV0dXJuaW5nIHN0YWxlIGNhY2hlIHdoZW4gdmVyc2lvbiByZWFkIGZhaWxzLiBEZWZhdWx0OiB0cnVlICovXG4gICAgYWxsb3dTdGFsZU9uVmVyc2lvbkVycm9yPzogYm9vbGVhbjtcbiAgfVxuKTogUHJvbWlzZTxUW10+IHtcbiAgY29uc3QgY2FjaGVLZXkgPSBDSyh0YWJsZSk7XG4gIGNvbnN0IGFsbG93U3RhbGUgPSBvcHRzPy5hbGxvd1N0YWxlT25WZXJzaW9uRXJyb3IgPz8gdHJ1ZTtcblxuICAvLyAxKSBSZWFkIGN1cnJlbnQgbGFzdENoYW5nZWQgZnJvbSBEQlxuICBsZXQgbGFzdENoYW5nZWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICB0cnkge1xuICAgIGxhc3RDaGFuZ2VkID0gYXdhaXQgZ2V0VGFibGVMYXN0Q2hhbmdlZCh0YWJsZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFZlcnNpb24gY2hlY2sgZmFpbGVkIChtaXNzaW5nIHRhYmxlX3ZlcnNpb25zIG9yIFJMUykuIE9wdGlvbmFsbHkgc2VydmUgc3RhbGUuXG4gICAgaWYgKCFhbGxvd1N0YWxlKSB0aHJvdyBuZXcgRXJyb3IodG9FcnJNZXNzYWdlKGVycikpO1xuXG4gICAgY29uc3QgY2FjaGVkUmF3ID0gc2FmZVJlYWRDYWNoZTxUPihjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFJhdykgcmV0dXJuIGNhY2hlZFJhdy5kYXRhO1xuICAgIC8vIEZhbGwgdGhyb3VnaCB0byBhIGRpcmVjdCBmZXRjaCBzbyBVSSBpc27igJl0IHN0dWNrXG4gIH1cblxuICAvLyAyKSBJZiB3ZSBoYXZlIGNhY2hlIGFuZCB2ZXJzaW9ucyBtYXRjaCDihpIgcmV0dXJuIGNhY2hlZFxuICBjb25zdCBjYWNoZWQgPSBzYWZlUmVhZENhY2hlPFQ+KGNhY2hlS2V5KTtcbiAgaWYgKGxhc3RDaGFuZ2VkICYmIGNhY2hlZD8ubGFzdENoYW5nZWQgPT09IGxhc3RDaGFuZ2VkKSB7XG4gICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xuICB9XG5cbiAgLy8gMykgRmV0Y2ggZnJlc2ggcm93c1xuICBjb25zdCByb3dzID0gYXdhaXQgZmV0Y2hUYWJsZVJvd3M8VD4odGFibGUsIGNvbHVtbnMsIHsgZnJvbTogb3B0cz8uZnJvbSwgdG86IG9wdHM/LnRvIH0pO1xuXG4gIC8vIDQpIFNhdmUgY2FjaGUgKGFsc28gQnJvYWRjYXN0Q2hhbm5lbCBpbnZhbGlkYXRpb24gdG8gb3RoZXIgdGFicyB2aWEgc2V0Q2FjaGUpXG4gIGNvbnN0IGZpbmFsTGFzdENoYW5nZWQgPSBsYXN0Q2hhbmdlZCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIHNldENhY2hlKGNhY2hlS2V5LCByb3dzLCBmaW5hbExhc3RDaGFuZ2VkKTtcblxuICByZXR1cm4gcm93cztcbn1cblxuLyoqXG4gKiBBbHdheXMgZmV0Y2ggZnJlc2ggKGlnbm9yZXMgbG9jYWwgY2FjaGUpIGFuZCB0aGVuIHJlZnJlc2ggdGhlIGNhY2hlIHdpdGggdGhlXG4gKiBsYXRlc3QgdmVyc2lvbiBmcm9tIHRhYmxlX3ZlcnNpb25zIGlmIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERiUm93c0ZyZXNoPFQgPSBhbnk+KFxuICB0YWJsZTogc3RyaW5nLFxuICBjb2x1bW5zOiBzdHJpbmdbXSxcbiAgb3B0cz86IHsgZnJvbT86IG51bWJlcjsgdG8/OiBudW1iZXIgfVxuKTogUHJvbWlzZTxUW10+IHtcbiAgY29uc3QgY2FjaGVLZXkgPSBDSyh0YWJsZSk7XG4gIGNvbnN0IHJvd3MgPSBhd2FpdCBmZXRjaFRhYmxlUm93czxUPih0YWJsZSwgY29sdW1ucywgeyBmcm9tOiBvcHRzPy5mcm9tLCB0bzogb3B0cz8udG8gfSk7XG4gIGxldCBsYXN0Q2hhbmdlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBsYXN0Q2hhbmdlZCA9IGF3YWl0IGdldFRhYmxlTGFzdENoYW5nZWQodGFibGUpO1xuICB9IGNhdGNoIHtcbiAgICAvLyBpZ25vcmUgdmVyc2lvbiBlcnJvcnM7IHN0aWxsIGNhY2hlIHdpdGggbm93KClcbiAgfVxuICBzZXRDYWNoZShjYWNoZUtleSwgcm93cywgbGFzdENoYW5nZWQpO1xuICByZXR1cm4gcm93cztcbn1cblxuLyoqIE1hbnVhbGx5IGludmFsaWRhdGUgb25lIHRhYmxl4oCZcyBjYWNoZSAoYW5kIG5vdGlmeSBvdGhlciB0YWJzKS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlRGJDYWNoZSh0YWJsZTogc3RyaW5nKSB7XG4gIGNsZWFyQ2FjaGUoQ0sodGFibGUpKTtcbn1cblxuLyoqIEJ1bGsgaW52YWxpZGF0ZSBtdWx0aXBsZSB0YWJsZXMuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZU1hbnlEYkNhY2hlcyh0YWJsZXM6IHN0cmluZ1tdKSB7XG4gIGZvciAoY29uc3QgdCBvZiB0YWJsZXMpIGNsZWFyQ2FjaGUoQ0sodCkpO1xufVxuXG4vKiogVXRpbGl0eTogc2FmZSByZWFkIG9mIHlvdXIgY2FjaGUgZW50cnkgZnJvbSBsb2NhbFN0b3JhZ2UgKG1pcnJvcnMgZGF0YUNhY2hl4oCZcyBzdG9yYWdlKS4gKi9cbmZ1bmN0aW9uIHNhZmVSZWFkQ2FjaGU8VCA9IGFueT4oa2V5OiBzdHJpbmcpOiBEYkNhY2hlRW50cnk8VD4gfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghcmF3KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpIGFzIERiQ2FjaGVFbnRyeTxUPjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInNldENhY2hlIiwiY2xlYXJDYWNoZSIsIkNLIiwidGFibGUiLCJ0b0Vyck1lc3NhZ2UiLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiU3RyaW5nIiwic2FuaXRpemVDb2x1bW5zIiwiY29scyIsIm91dCIsImZpbHRlciIsImMiLCJ0cmltIiwibGVuZ3RoIiwibWFwIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZ2V0VGFibGVMYXN0Q2hhbmdlZCIsImRhdGEiLCJlcnJvciIsInNlbGVjdCIsImVxIiwibWF5YmVTaW5nbGUiLCJ3aGVyZSIsImRldGFpbHMiLCJoaW50IiwiY29kZSIsImlzbyIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJlIiwiZmV0Y2hUYWJsZVJvd3MiLCJjb2x1bW5zIiwib3B0cyIsImNsZWFuZWQiLCJzZWxlY3RDb2xzIiwiam9pbiIsImNvbnNvbGUiLCJpbmZvIiwicSIsInRvIiwicmFuZ2UiLCJnZXREYlJvd3NDYWNoZWQiLCJjYWNoZUtleSIsImFsbG93U3RhbGUiLCJhbGxvd1N0YWxlT25WZXJzaW9uRXJyb3IiLCJsYXN0Q2hhbmdlZCIsImNhY2hlZFJhdyIsInNhZmVSZWFkQ2FjaGUiLCJjYWNoZWQiLCJyb3dzIiwiZmluYWxMYXN0Q2hhbmdlZCIsImdldERiUm93c0ZyZXNoIiwiaW52YWxpZGF0ZURiQ2FjaGUiLCJpbnZhbGlkYXRlTWFueURiQ2FjaGVzIiwidGFibGVzIiwidCIsImtleSIsInJhdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/databaseService.ts\n"));

/***/ })

});