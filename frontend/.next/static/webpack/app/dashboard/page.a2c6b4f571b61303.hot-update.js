"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/dataCache.ts":
/*!******************************!*\
  !*** ./src/lib/dataCache.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   broadcastInvalidate: () => (/* binding */ broadcastInvalidate),\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   clearMany: () => (/* binding */ clearMany),\n/* harmony export */   formatLastChanged: () => (/* binding */ formatLastChanged),\n/* harmony export */   getLastChangedFromCache: () => (/* binding */ getLastChangedFromCache),\n/* harmony export */   getWithVersionCache: () => (/* binding */ getWithVersionCache),\n/* harmony export */   isCacheVersion: () => (/* binding */ isCacheVersion),\n/* harmony export */   peekCache: () => (/* binding */ peekCache),\n/* harmony export */   setCache: () => (/* binding */ setCache)\n/* harmony export */ });\n// src/lib/dataCache.ts\nconst DEFAULT_VERSION_URL = '/api/dashboard/version';\nconst LS_PREFIX = ''; // e.g., 'curricalign:' if you want namespacing\nconst DEFAULT_TTL_MS = 1000 * 60 * 60 * 24 * 7; // 7 days fallback if version is unreachable\n/* =============================================================================\n   BroadcastChannel for cross-tab invalidation\n============================================================================= */ const BC_NAME = 'dash-cache';\nconst hasWindow = \"object\" !== 'undefined';\nconst hasBC = hasWindow && 'BroadcastChannel' in window;\nconst bc = hasBC ? new BroadcastChannel(BC_NAME) : null;\nfunction broadcastInvalidate(cacheKey) {\n    bc === null || bc === void 0 ? void 0 : bc.postMessage({\n        type: 'invalidate',\n        cacheKey\n    });\n}\nif (bc) {\n    bc.addEventListener('message', (ev)=>{\n        const msg = ev === null || ev === void 0 ? void 0 : ev.data;\n        if ((msg === null || msg === void 0 ? void 0 : msg.type) === 'invalidate' && typeof (msg === null || msg === void 0 ? void 0 : msg.cacheKey) === 'string') {\n            try {\n                if (!hasWindow || !('localStorage' in window)) return;\n                localStorage.removeItem(msg.cacheKey);\n            } catch (e) {\n            /* ignore */ }\n        }\n    });\n}\n/* =============================================================================\n   localStorage helpers (SSR safe)\n============================================================================= */ function k(key) {\n    return LS_PREFIX + key;\n}\nfunction readCache(key) {\n    try {\n        if (!hasWindow || !('localStorage' in window)) return null;\n        const raw = localStorage.getItem(k(key));\n        if (!raw) return null;\n        return JSON.parse(raw);\n    } catch (e) {\n        return null;\n    }\n}\nfunction writeCache(key, entry) {\n    try {\n        if (!hasWindow || !('localStorage' in window)) return;\n        localStorage.setItem(k(key), JSON.stringify(entry));\n    } catch (e) {\n    /* ignore */ }\n}\nfunction clearCache(key) {\n    try {\n        if (!hasWindow || !('localStorage' in window)) return;\n        localStorage.removeItem(k(key));\n        broadcastInvalidate(k(key));\n    } catch (e) {\n    /* ignore */ }\n}\nfunction peekCache(key) {\n    return readCache(key);\n}\nfunction getLastChangedFromCache(key) {\n    const c = readCache(key);\n    var _c_lastChanged;\n    return (_c_lastChanged = c === null || c === void 0 ? void 0 : c.lastChanged) !== null && _c_lastChanged !== void 0 ? _c_lastChanged : null;\n}\nfunction formatLastChanged(iso) {\n    if (!iso) return '';\n    try {\n        return new Date(iso).toLocaleString();\n    } catch (e) {\n        return iso;\n    }\n}\n/* =============================================================================\n   HTTP helpers\n============================================================================= */ async function fetchJSON(url, init, signal) {\n    var _init_headers;\n    const res = await fetch(url, {\n        ...init,\n        signal,\n        cache: 'no-store',\n        headers: {\n            Accept: 'application/json',\n            ...(_init_headers = init === null || init === void 0 ? void 0 : init.headers) !== null && _init_headers !== void 0 ? _init_headers : {}\n        }\n    });\n    if (res.status === 304) {\n        var _res_headers_get;\n        // Callers treat 304 as \"use cached\"; we return a compatible shape\n        return {\n            data: undefined,\n            etag: (_res_headers_get = res.headers.get('ETag')) !== null && _res_headers_get !== void 0 ? _res_headers_get : undefined\n        };\n    }\n    if (!res.ok) {\n        const text = await res.text().catch(()=>'');\n        throw new Error(\"GET \".concat(url, \" failed: \").concat(res.status, \" \").concat(text));\n    }\n    var _res_headers_get1;\n    const etag = (_res_headers_get1 = res.headers.get('ETag')) !== null && _res_headers_get1 !== void 0 ? _res_headers_get1 : undefined;\n    const data = await res.json();\n    return {\n        data,\n        etag\n    };\n}\n/* =============================================================================\n   Core: version-gated cache fetch\n============================================================================= */ /**\n * Fetch dashboard data with version guarding:\n *  1) GET versionUrl (sends If-None-Match if we have an ETag)\n *     - if 304 and we have cache → return cache\n *     - if 200, compare lastChanged with cache\n *  2) If changed or no cache → GET dataUrl, cache with new version/etag\n *  3) If version fails, optionally serve bounded-stale cache by TTL\n */ async function getWithVersionCache(cacheKey, dataUrl) {\n    let versionUrl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_VERSION_URL, signal = arguments.length > 3 ? arguments[3] : void 0, opts = arguments.length > 4 ? arguments[4] : void 0;\n    var _opts_ttlMs;\n    const ttlMs = (_opts_ttlMs = opts === null || opts === void 0 ? void 0 : opts.ttlMs) !== null && _opts_ttlMs !== void 0 ? _opts_ttlMs : DEFAULT_TTL_MS;\n    const cached = readCache(cacheKey);\n    // 1) Check /version first (cheap), with ETag for 304 hits\n    const versionInit = {};\n    if (cached === null || cached === void 0 ? void 0 : cached.etag) {\n        versionInit.headers = {\n            ...versionInit.headers || {},\n            'If-None-Match': cached.etag\n        };\n    }\n    try {\n        const vRes = await fetch(versionUrl, {\n            ...versionInit,\n            signal,\n            cache: 'no-store',\n            headers: {\n                ...versionInit.headers || {},\n                Accept: 'application/json'\n            }\n        });\n        if (vRes.status === 304 && cached) {\n            return {\n                data: cached.data,\n                lastChanged: cached.lastChanged\n            };\n        }\n        if (!vRes.ok) {\n            throw new Error(\"Version check failed: \".concat(vRes.status));\n        }\n        var _vRes_headers_get;\n        const vEtag = (_vRes_headers_get = vRes.headers.get('ETag')) !== null && _vRes_headers_get !== void 0 ? _vRes_headers_get : undefined;\n        const { lastChanged } = await vRes.json();\n        // Version same → serve cache\n        if (cached && cached.lastChanged === lastChanged) {\n            return {\n                data: cached.data,\n                lastChanged: cached.lastChanged\n            };\n        }\n        // 2) Version changed or no cache → fetch fresh data\n        const { data } = await fetchJSON(dataUrl, undefined, signal);\n        const entry = {\n            data,\n            lastChanged,\n            cachedAt: new Date().toISOString(),\n            etag: vEtag\n        };\n        writeCache(cacheKey, entry);\n        return {\n            data,\n            lastChanged\n        };\n    } catch (err) {\n        // 3) If /version fails, serve bounded-stale cache (TTL) if allowed\n        if (cached && (opts === null || opts === void 0 ? void 0 : opts.allowStaleOnVersionError) !== false) {\n            const age = Date.now() - new Date(cached.cachedAt).getTime();\n            if (age <= ttlMs) {\n                return {\n                    data: cached.data,\n                    lastChanged: cached.lastChanged\n                };\n            }\n        }\n        // As a last resort, fetch data directly (no version guard)\n        if (!(signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n            const { data } = await fetchJSON(dataUrl, undefined, signal);\n            const nowIso = new Date().toISOString();\n            var _cached_lastChanged;\n            const entry = {\n                data,\n                lastChanged: (_cached_lastChanged = cached === null || cached === void 0 ? void 0 : cached.lastChanged) !== null && _cached_lastChanged !== void 0 ? _cached_lastChanged : nowIso,\n                cachedAt: nowIso,\n                etag: cached === null || cached === void 0 ? void 0 : cached.etag\n            };\n            writeCache(cacheKey, entry);\n            return {\n                data,\n                lastChanged: entry.lastChanged\n            };\n        }\n        throw err;\n    }\n}\n/* =============================================================================\n   Convenience utilities\n============================================================================= */ /** Manually set cache (e.g., after optimistic updates). */ function setCache(cacheKey, data, lastChangedISO, etag) {\n    writeCache(cacheKey, {\n        data,\n        lastChanged: lastChangedISO,\n        cachedAt: new Date().toISOString(),\n        etag\n    });\n    // notify other tabs to drop their local copy so they re-read on next access\n    broadcastInvalidate(k(cacheKey));\n}\n/** Invalidate multiple keys at once. */ function clearMany(keys) {\n    for (const key of keys)clearCache(key);\n}\n/** True if a cached entry exists and matches a given lastChanged value. */ function isCacheVersion(cacheKey, lastChangedISO) {\n    const c = readCache(cacheKey);\n    return !!(c && c.lastChanged === lastChangedISO);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGF0YUNhY2hlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHVCQUF1QjtBQVN2QixNQUFNQSxzQkFBc0I7QUFDNUIsTUFBTUMsWUFBWSxJQUFJLCtDQUErQztBQUNyRSxNQUFNQyxpQkFBaUIsT0FBTyxLQUFLLEtBQUssS0FBSyxHQUFHLDRDQUE0QztBQUU1Rjs7OEVBRThFLEdBRTlFLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsWUFBWSxhQUFrQjtBQUNwQyxNQUFNQyxRQUFRRCxhQUFhLHNCQUFzQkU7QUFFakQsTUFBTUMsS0FBOEJGLFFBQVEsSUFBSUcsaUJBQWlCTCxXQUFXO0FBRXJFLFNBQVNNLG9CQUFvQkMsUUFBZ0I7SUFDbERILGVBQUFBLHlCQUFBQSxHQUFJSSxXQUFXLENBQUM7UUFBRUMsTUFBTTtRQUFjRjtJQUFTO0FBQ2pEO0FBRUEsSUFBSUgsSUFBSTtJQUNOQSxHQUFHTSxnQkFBZ0IsQ0FBQyxXQUFXLENBQUNDO1FBQzlCLE1BQU1DLE1BQU1ELGVBQUFBLHlCQUFBQSxHQUFJRSxJQUFJO1FBQ3BCLElBQUlELENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBS0gsSUFBSSxNQUFLLGdCQUFnQixRQUFPRyxnQkFBQUEsMEJBQUFBLElBQUtMLFFBQVEsTUFBSyxVQUFVO1lBQ25FLElBQUk7Z0JBQ0YsSUFBSSxDQUFDTixhQUFhLENBQUUsbUJBQWtCRSxNQUFLLEdBQUk7Z0JBQy9DVyxhQUFhQyxVQUFVLENBQUNILElBQUlMLFFBQVE7WUFDdEMsRUFBRSxVQUFNO1lBQ04sVUFBVSxHQUNaO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7OzhFQUU4RSxHQUU5RSxTQUFTUyxFQUFFQyxHQUFXO0lBQ3BCLE9BQU9uQixZQUFZbUI7QUFDckI7QUFFQSxTQUFTQyxVQUFhRCxHQUFXO0lBQy9CLElBQUk7UUFDRixJQUFJLENBQUNoQixhQUFhLENBQUUsbUJBQWtCRSxNQUFLLEdBQUksT0FBTztRQUN0RCxNQUFN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SUFDRjtJQUNBLDRFQUE0RTtJQUM1RXpDLG9CQUFvQlUsRUFBRVQ7QUFDeEI7QUFFQSxzQ0FBc0MsR0FDL0IsU0FBU21FLFVBQVVDLElBQWM7SUFDdEMsS0FBSyxNQUFNMUQsT0FBTzBELEtBQU1oRCxXQUFXVjtBQUNyQztBQUVBLHlFQUF5RSxHQUNsRSxTQUFTMkQsZUFBZXJFLFFBQWdCLEVBQUVrRSxjQUFzQjtJQUNyRSxNQUFNM0MsSUFBSVosVUFBbUJYO0lBQzdCLE9BQU8sQ0FBQyxDQUFFdUIsQ0FBQUEsS0FBS0EsRUFBRUMsV0FBVyxLQUFLMEMsY0FBYTtBQUNoRCIsInNvdXJjZXMiOlsiL1VzZXJzL3N0YWwvRG9jdW1lbnRzL1Byb2plY3RzL2N1cnJpY2FsaWduL2Zyb250ZW5kL3NyYy9saWIvZGF0YUNhY2hlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvZGF0YUNhY2hlLnRzXG5cbmV4cG9ydCB0eXBlIENhY2hlRW50cnk8VD4gPSB7XG4gIGRhdGE6IFQ7XG4gIGxhc3RDaGFuZ2VkOiBzdHJpbmc7IC8vIElTTyBmcm9tIC92ZXJzaW9uXG4gIGNhY2hlZEF0OiBzdHJpbmc7ICAgIC8vIElTTyB3aGVuIHdlIGNhY2hlZCBsb2NhbGx5XG4gIGV0YWc/OiBzdHJpbmc7ICAgICAgIC8vIG9wdGlvbmFsIEVUYWcgZnJvbSAvdmVyc2lvblxufTtcblxuY29uc3QgREVGQVVMVF9WRVJTSU9OX1VSTCA9ICcvYXBpL2Rhc2hib2FyZC92ZXJzaW9uJztcbmNvbnN0IExTX1BSRUZJWCA9ICcnOyAvLyBlLmcuLCAnY3VycmljYWxpZ246JyBpZiB5b3Ugd2FudCBuYW1lc3BhY2luZ1xuY29uc3QgREVGQVVMVF9UVExfTVMgPSAxMDAwICogNjAgKiA2MCAqIDI0ICogNzsgLy8gNyBkYXlzIGZhbGxiYWNrIGlmIHZlcnNpb24gaXMgdW5yZWFjaGFibGVcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIEJyb2FkY2FzdENoYW5uZWwgZm9yIGNyb3NzLXRhYiBpbnZhbGlkYXRpb25cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbmNvbnN0IEJDX05BTUUgPSAnZGFzaC1jYWNoZSc7XG5jb25zdCBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGhhc0JDID0gaGFzV2luZG93ICYmICdCcm9hZGNhc3RDaGFubmVsJyBpbiB3aW5kb3c7XG5cbmNvbnN0IGJjOiBCcm9hZGNhc3RDaGFubmVsIHwgbnVsbCA9IGhhc0JDID8gbmV3IEJyb2FkY2FzdENoYW5uZWwoQkNfTkFNRSkgOiBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gYnJvYWRjYXN0SW52YWxpZGF0ZShjYWNoZUtleTogc3RyaW5nKSB7XG4gIGJjPy5wb3N0TWVzc2FnZSh7IHR5cGU6ICdpbnZhbGlkYXRlJywgY2FjaGVLZXkgfSk7XG59XG5cbmlmIChiYykge1xuICBiYy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICBjb25zdCBtc2cgPSBldj8uZGF0YTtcbiAgICBpZiAobXNnPy50eXBlID09PSAnaW52YWxpZGF0ZScgJiYgdHlwZW9mIG1zZz8uY2FjaGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWhhc1dpbmRvdyB8fCAhKCdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdykpIHJldHVybjtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obXNnLmNhY2hlS2V5KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvKiBpZ25vcmUgKi9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgbG9jYWxTdG9yYWdlIGhlbHBlcnMgKFNTUiBzYWZlKVxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuZnVuY3Rpb24gayhrZXk6IHN0cmluZykge1xuICByZXR1cm4gTFNfUFJFRklYICsga2V5O1xufVxuXG5mdW5jdGlvbiByZWFkQ2FjaGU8VD4oa2V5OiBzdHJpbmcpOiBDYWNoZUVudHJ5PFQ+IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgaWYgKCFoYXNXaW5kb3cgfHwgISgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cpKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrKGtleSkpO1xuICAgIGlmICghcmF3KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpIGFzIENhY2hlRW50cnk8VD47XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQ2FjaGU8VD4oa2V5OiBzdHJpbmcsIGVudHJ5OiBDYWNoZUVudHJ5PFQ+KSB7XG4gIHRyeSB7XG4gICAgaWYgKCFoYXNXaW5kb3cgfHwgISgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cpKSByZXR1cm47XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oayhrZXkpLCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xuICB9IGNhdGNoIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZShrZXk6IHN0cmluZykge1xuICB0cnkge1xuICAgIGlmICghaGFzV2luZG93IHx8ICEoJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93KSkgcmV0dXJuO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGsoa2V5KSk7XG4gICAgYnJvYWRjYXN0SW52YWxpZGF0ZShrKGtleSkpO1xuICB9IGNhdGNoIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGVla0NhY2hlPFQ+KGtleTogc3RyaW5nKTogQ2FjaGVFbnRyeTxUPiB8IG51bGwge1xuICByZXR1cm4gcmVhZENhY2hlPFQ+KGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXN0Q2hhbmdlZEZyb21DYWNoZShrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBjID0gcmVhZENhY2hlPHVua25vd24+KGtleSk7XG4gIHJldHVybiBjPy5sYXN0Q2hhbmdlZCA/PyBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TGFzdENoYW5nZWQoaXNvPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc28pIHJldHVybiAnJztcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IERhdGUoaXNvKS50b0xvY2FsZVN0cmluZygpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gaXNvO1xuICB9XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBIVFRQIGhlbHBlcnNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoSlNPTjxUPihcbiAgdXJsOiBzdHJpbmcsXG4gIGluaXQ/OiBSZXF1ZXN0SW5pdCxcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbik6IFByb21pc2U8eyBkYXRhOiBUOyBldGFnPzogc3RyaW5nIH0+IHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgLi4uaW5pdCxcbiAgICBzaWduYWwsXG4gICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi4oaW5pdD8uaGVhZGVycyA/PyB7fSksXG4gICAgfSxcbiAgfSk7XG5cbiAgaWYgKHJlcy5zdGF0dXMgPT09IDMwNCkge1xuICAgIC8vIENhbGxlcnMgdHJlYXQgMzA0IGFzIFwidXNlIGNhY2hlZFwiOyB3ZSByZXR1cm4gYSBjb21wYXRpYmxlIHNoYXBlXG4gICAgcmV0dXJuIHsgZGF0YTogdW5kZWZpbmVkIGFzIHVua25vd24gYXMgVCwgZXRhZzogcmVzLmhlYWRlcnMuZ2V0KCdFVGFnJykgPz8gdW5kZWZpbmVkIH07XG4gIH1cblxuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+ICcnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEdFVCAke3VybH0gZmFpbGVkOiAke3Jlcy5zdGF0dXN9ICR7dGV4dH1gKTtcbiAgfVxuXG4gIGNvbnN0IGV0YWcgPSByZXMuaGVhZGVycy5nZXQoJ0VUYWcnKSA/PyB1bmRlZmluZWQ7XG4gIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzLmpzb24oKSkgYXMgVDtcbiAgcmV0dXJuIHsgZGF0YSwgZXRhZyB9O1xufVxuXG50eXBlIFZlcnNpb25SZXNwb25zZSA9IHsgbGFzdENoYW5nZWQ6IHN0cmluZyB9O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgQ29yZTogdmVyc2lvbi1nYXRlZCBjYWNoZSBmZXRjaFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBGZXRjaCBkYXNoYm9hcmQgZGF0YSB3aXRoIHZlcnNpb24gZ3VhcmRpbmc6XG4gKiAgMSkgR0VUIHZlcnNpb25VcmwgKHNlbmRzIElmLU5vbmUtTWF0Y2ggaWYgd2UgaGF2ZSBhbiBFVGFnKVxuICogICAgIC0gaWYgMzA0IGFuZCB3ZSBoYXZlIGNhY2hlIOKGkiByZXR1cm4gY2FjaGVcbiAqICAgICAtIGlmIDIwMCwgY29tcGFyZSBsYXN0Q2hhbmdlZCB3aXRoIGNhY2hlXG4gKiAgMikgSWYgY2hhbmdlZCBvciBubyBjYWNoZSDihpIgR0VUIGRhdGFVcmwsIGNhY2hlIHdpdGggbmV3IHZlcnNpb24vZXRhZ1xuICogIDMpIElmIHZlcnNpb24gZmFpbHMsIG9wdGlvbmFsbHkgc2VydmUgYm91bmRlZC1zdGFsZSBjYWNoZSBieSBUVExcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdpdGhWZXJzaW9uQ2FjaGU8VD4oXG4gIGNhY2hlS2V5OiBzdHJpbmcsXG4gIGRhdGFVcmw6IHN0cmluZyxcbiAgdmVyc2lvblVybDogc3RyaW5nID0gREVGQVVMVF9WRVJTSU9OX1VSTCxcbiAgc2lnbmFsPzogQWJvcnRTaWduYWwsXG4gIG9wdHM/OiB7XG4gICAgLyoqIE9wdGlvbmFsIFRUTCBhcyBhIHNhZmV0eSB2YWx2ZSBpZiAvdmVyc2lvbiBpcyB0ZW1wb3JhcmlseSB1bnJlYWNoYWJsZS4gRGVmYXVsdCA3ZC4gKi9cbiAgICB0dGxNcz86IG51bWJlcjtcbiAgICAvKiogSWYgdHJ1ZSwgd2lsbCBzdGlsbCByZXR1cm4gY2FjaGVkIGRhdGEgd2hlbiAvdmVyc2lvbiBlcnJvcnMuICovXG4gICAgYWxsb3dTdGFsZU9uVmVyc2lvbkVycm9yPzogYm9vbGVhbjtcbiAgfVxuKTogUHJvbWlzZTx7IGRhdGE6IFQ7IGxhc3RDaGFuZ2VkOiBzdHJpbmcgfT4ge1xuICBjb25zdCB0dGxNcyA9IG9wdHM/LnR0bE1zID8/IERFRkFVTFRfVFRMX01TO1xuICBjb25zdCBjYWNoZWQgPSByZWFkQ2FjaGU8VD4oY2FjaGVLZXkpO1xuXG4gIC8vIDEpIENoZWNrIC92ZXJzaW9uIGZpcnN0IChjaGVhcCksIHdpdGggRVRhZyBmb3IgMzA0IGhpdHNcbiAgY29uc3QgdmVyc2lvbkluaXQ6IFJlcXVlc3RJbml0ID0ge307XG4gIGlmIChjYWNoZWQ/LmV0YWcpIHtcbiAgICB2ZXJzaW9uSW5pdC5oZWFkZXJzID0geyAuLi4odmVyc2lvbkluaXQuaGVhZGVycyB8fCB7fSksICdJZi1Ob25lLU1hdGNoJzogY2FjaGVkLmV0YWcgfTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdlJlcyA9IGF3YWl0IGZldGNoKHZlcnNpb25VcmwsIHtcbiAgICAgIC4uLnZlcnNpb25Jbml0LFxuICAgICAgc2lnbmFsLFxuICAgICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLih2ZXJzaW9uSW5pdC5oZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKHZSZXMuc3RhdHVzID09PSAzMDQgJiYgY2FjaGVkKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBjYWNoZWQuZGF0YSwgbGFzdENoYW5nZWQ6IGNhY2hlZC5sYXN0Q2hhbmdlZCB9O1xuICAgIH1cblxuICAgIGlmICghdlJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBWZXJzaW9uIGNoZWNrIGZhaWxlZDogJHt2UmVzLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB2RXRhZyA9IHZSZXMuaGVhZGVycy5nZXQoJ0VUYWcnKSA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyBsYXN0Q2hhbmdlZCB9ID0gKGF3YWl0IHZSZXMuanNvbigpKSBhcyBWZXJzaW9uUmVzcG9uc2U7XG5cbiAgICAvLyBWZXJzaW9uIHNhbWUg4oaSIHNlcnZlIGNhY2hlXG4gICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQubGFzdENoYW5nZWQgPT09IGxhc3RDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBjYWNoZWQuZGF0YSwgbGFzdENoYW5nZWQ6IGNhY2hlZC5sYXN0Q2hhbmdlZCB9O1xuICAgIH1cblxuICAgIC8vIDIpIFZlcnNpb24gY2hhbmdlZCBvciBubyBjYWNoZSDihpIgZmV0Y2ggZnJlc2ggZGF0YVxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZmV0Y2hKU09OPFQ+KGRhdGFVcmwsIHVuZGVmaW5lZCwgc2lnbmFsKTtcbiAgICBjb25zdCBlbnRyeTogQ2FjaGVFbnRyeTxUPiA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBsYXN0Q2hhbmdlZCxcbiAgICAgIGNhY2hlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBldGFnOiB2RXRhZyxcbiAgICB9O1xuICAgIHdyaXRlQ2FjaGU8VD4oY2FjaGVLZXksIGVudHJ5KTtcbiAgICByZXR1cm4geyBkYXRhLCBsYXN0Q2hhbmdlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAzKSBJZiAvdmVyc2lvbiBmYWlscywgc2VydmUgYm91bmRlZC1zdGFsZSBjYWNoZSAoVFRMKSBpZiBhbGxvd2VkXG4gICAgaWYgKGNhY2hlZCAmJiBvcHRzPy5hbGxvd1N0YWxlT25WZXJzaW9uRXJyb3IgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUoY2FjaGVkLmNhY2hlZEF0KS5nZXRUaW1lKCk7XG4gICAgICBpZiAoYWdlIDw9IHR0bE1zKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGNhY2hlZC5kYXRhLCBsYXN0Q2hhbmdlZDogY2FjaGVkLmxhc3RDaGFuZ2VkIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzIGEgbGFzdCByZXNvcnQsIGZldGNoIGRhdGEgZGlyZWN0bHkgKG5vIHZlcnNpb24gZ3VhcmQpXG4gICAgaWYgKCFzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZmV0Y2hKU09OPFQ+KGRhdGFVcmwsIHVuZGVmaW5lZCwgc2lnbmFsKTtcbiAgICAgIGNvbnN0IG5vd0lzbyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGVudHJ5OiBDYWNoZUVudHJ5PFQ+ID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBsYXN0Q2hhbmdlZDogY2FjaGVkPy5sYXN0Q2hhbmdlZCA/PyBub3dJc28sXG4gICAgICAgIGNhY2hlZEF0OiBub3dJc28sXG4gICAgICAgIGV0YWc6IGNhY2hlZD8uZXRhZyxcbiAgICAgIH07XG4gICAgICB3cml0ZUNhY2hlPFQ+KGNhY2hlS2V5LCBlbnRyeSk7XG4gICAgICByZXR1cm4geyBkYXRhLCBsYXN0Q2hhbmdlZDogZW50cnkubGFzdENoYW5nZWQgfTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBDb252ZW5pZW5jZSB1dGlsaXRpZXNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKiBNYW51YWxseSBzZXQgY2FjaGUgKGUuZy4sIGFmdGVyIG9wdGltaXN0aWMgdXBkYXRlcykuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2FjaGU8VD4oY2FjaGVLZXk6IHN0cmluZywgZGF0YTogVCwgbGFzdENoYW5nZWRJU086IHN0cmluZywgZXRhZz86IHN0cmluZykge1xuICB3cml0ZUNhY2hlPFQ+KGNhY2hlS2V5LCB7XG4gICAgZGF0YSxcbiAgICBsYXN0Q2hhbmdlZDogbGFzdENoYW5nZWRJU08sXG4gICAgY2FjaGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBldGFnLFxuICB9KTtcbiAgLy8gbm90aWZ5IG90aGVyIHRhYnMgdG8gZHJvcCB0aGVpciBsb2NhbCBjb3B5IHNvIHRoZXkgcmUtcmVhZCBvbiBuZXh0IGFjY2Vzc1xuICBicm9hZGNhc3RJbnZhbGlkYXRlKGsoY2FjaGVLZXkpKTtcbn1cblxuLyoqIEludmFsaWRhdGUgbXVsdGlwbGUga2V5cyBhdCBvbmNlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTWFueShrZXlzOiBzdHJpbmdbXSkge1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSBjbGVhckNhY2hlKGtleSk7XG59XG5cbi8qKiBUcnVlIGlmIGEgY2FjaGVkIGVudHJ5IGV4aXN0cyBhbmQgbWF0Y2hlcyBhIGdpdmVuIGxhc3RDaGFuZ2VkIHZhbHVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FjaGVWZXJzaW9uKGNhY2hlS2V5OiBzdHJpbmcsIGxhc3RDaGFuZ2VkSVNPOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYyA9IHJlYWRDYWNoZTx1bmtub3duPihjYWNoZUtleSk7XG4gIHJldHVybiAhIShjICYmIGMubGFzdENoYW5nZWQgPT09IGxhc3RDaGFuZ2VkSVNPKTtcbn1cbiJdLCJuYW1lcyI6WyJERUZBVUxUX1ZFUlNJT05fVVJMIiwiTFNfUFJFRklYIiwiREVGQVVMVF9UVExfTVMiLCJCQ19OQU1FIiwiaGFzV2luZG93IiwiaGFzQkMiLCJ3aW5kb3ciLCJiYyIsIkJyb2FkY2FzdENoYW5uZWwiLCJicm9hZGNhc3RJbnZhbGlkYXRlIiwiY2FjaGVLZXkiLCJwb3N0TWVzc2FnZSIsInR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXYiLCJtc2ciLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsImsiLCJrZXkiLCJyZWFkQ2FjaGUiLCJyYXciLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwid3JpdGVDYWNoZSIsImVudHJ5Iiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImNsZWFyQ2FjaGUiLCJwZWVrQ2FjaGUiLCJnZXRMYXN0Q2hhbmdlZEZyb21DYWNoZSIsImMiLCJsYXN0Q2hhbmdlZCIsImZvcm1hdExhc3RDaGFuZ2VkIiwiaXNvIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiZmV0Y2hKU09OIiwidXJsIiwiaW5pdCIsInNpZ25hbCIsInJlcyIsImZldGNoIiwiY2FjaGUiLCJoZWFkZXJzIiwiQWNjZXB0Iiwic3RhdHVzIiwidW5kZWZpbmVkIiwiZXRhZyIsImdldCIsIm9rIiwidGV4dCIsImNhdGNoIiwiRXJyb3IiLCJqc29uIiwiZ2V0V2l0aFZlcnNpb25DYWNoZSIsImRhdGFVcmwiLCJ2ZXJzaW9uVXJsIiwib3B0cyIsInR0bE1zIiwiY2FjaGVkIiwidmVyc2lvbkluaXQiLCJ2UmVzIiwidkV0YWciLCJjYWNoZWRBdCIsInRvSVNPU3RyaW5nIiwiZXJyIiwiYWxsb3dTdGFsZU9uVmVyc2lvbkVycm9yIiwiYWdlIiwibm93IiwiZ2V0VGltZSIsImFib3J0ZWQiLCJub3dJc28iLCJzZXRDYWNoZSIsImxhc3RDaGFuZ2VkSVNPIiwiY2xlYXJNYW55Iiwia2V5cyIsImlzQ2FjaGVWZXJzaW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/dataCache.ts\n"));

/***/ })

});