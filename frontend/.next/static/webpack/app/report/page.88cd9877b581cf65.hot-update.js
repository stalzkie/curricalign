"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/report/page",{

/***/ "(app-pages-browser)/./src/components/report/useOrchestrator.ts":
/*!**************************************************!*\
  !*** ./src/components/report/useOrchestrator.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOrchestrator: () => (/* binding */ useOrchestrator)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./src/components/report/constants.ts\");\n// useOrchestrator.ts\n/* __next_internal_client_entry_do_not_use__ useOrchestrator auto */ \n\nfunction sleep(ms) {\n    return new Promise((r)=>setTimeout(r, ms));\n}\nfunction toAbsoluteUrl(url) {\n    try {\n        // If it's already absolute, this will succeed.\n        return new URL(url).toString();\n    } catch (e) {\n        var _API_BASE_replace;\n        // Make it absolute relative to API_BASE.\n        const base = (_API_BASE_replace = _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === null || _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === void 0 ? void 0 : _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE.replace(/\\/+$/, '')) !== null && _API_BASE_replace !== void 0 ? _API_BASE_replace : '';\n        const path = url.startsWith('/') ? url : \"/\".concat(url);\n        return \"\".concat(base).concat(path);\n    }\n}\n/** Probe URL until it responds OK. Tries HEAD, falls back to GET if needed. */ async function waitUntilReachable(url) {\n    let tries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, delayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500;\n    const abs = toAbsoluteUrl(url);\n    for(let i = 0; i < tries; i++){\n        const bust = \"_t=\".concat(Date.now(), \"-\").concat(i);\n        const sep = abs.includes('?') ? '&' : '?';\n        const probeUrl = \"\".concat(abs).concat(sep).concat(bust);\n        try {\n            let res = await fetch(probeUrl, {\n                method: 'HEAD',\n                cache: 'no-store'\n            });\n            if (res.ok) return true;\n            // If HEAD not supported, try GET without downloading body\n            if (res.status === 405 || res.status === 501) {\n                res = await fetch(probeUrl, {\n                    method: 'GET',\n                    cache: 'no-store'\n                });\n                if (res.ok) return true;\n            }\n        } catch (e) {\n        // ignore and retry\n        }\n        await sleep(delayMs);\n    }\n    return false;\n}\n/** Download a URL as a file without page navigation. */ async function downloadUrlAsFile(url, filename) {\n    const abs = toAbsoluteUrl(url);\n    const bust = abs.includes('?') ? '&' : '?';\n    const res = await fetch(\"\".concat(abs).concat(bust, \"_dl=\").concat(Date.now()), {\n        cache: 'no-store'\n    });\n    if (!res.ok) throw new Error(\"Download failed: \".concat(res.status));\n    const blob = await res.blob();\n    const objectUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = objectUrl;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(objectUrl);\n}\nfunction useOrchestrator() {\n    const [steps, setSteps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS);\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [reportUrl, setReportUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [jobId, setJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const esRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const cancelledRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const openedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const downloadStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const closeStream = ()=>{\n        try {\n            var _esRef_current;\n            (_esRef_current = esRef.current) === null || _esRef_current === void 0 ? void 0 : _esRef_current.close();\n        } catch (e) {}\n        esRef.current = null;\n        openedRef.current = false;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            return ({\n                \"useOrchestrator.useEffect\": ()=>closeStream()\n            })[\"useOrchestrator.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], []);\n    // Auto-download when reportUrl arrives â€” WITHOUT navigating\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            ({\n                \"useOrchestrator.useEffect\": async ()=>{\n                    if (!reportUrl || downloadStartedRef.current) return;\n                    downloadStartedRef.current = true;\n                    try {\n                        const reachable = await waitUntilReachable(reportUrl, 14, 500);\n                        if (!reachable) throw new Error('Report URL is not reachable yet');\n                        const suggested = \"alignment_report_\".concat(jobId !== null && jobId !== void 0 ? jobId : Date.now(), \".pdf\");\n                        await downloadUrlAsFile(reportUrl, suggested);\n                    } catch (err) {\n                        console.error('FRONTEND: Auto-download failed:', err);\n                        // allow manual retry by resetting the flag if needed\n                        downloadStartedRef.current = false;\n                    }\n                }\n            })[\"useOrchestrator.useEffect\"]();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], [\n        reportUrl,\n        jobId\n    ]);\n    const resetUI = ()=>{\n        setIsProcessing(true);\n        setIsComplete(false);\n        setReportUrl(null);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        cancelledRef.current = false;\n        downloadStartedRef.current = false;\n    };\n    async function uploadPdf(file) {\n        const form = new FormData();\n        form.append('file', file);\n        const res = await fetch(_constants__WEBPACK_IMPORTED_MODULE_1__.PDF_UPLOAD_URL, {\n            method: 'POST',\n            body: form\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || 'Failed to upload PDF');\n        }\n    }\n    async function initOrchestratorJob() {\n        console.log('FRONTEND: Requesting new jobId from backend...');\n        const res = await fetch(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_INIT_URL, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({})\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || 'Failed to initialize orchestrator job');\n        }\n        const data = await res.json().catch(()=>({}));\n        if (data === null || data === void 0 ? void 0 : data.jobId) {\n            setJobId(String(data.jobId));\n            console.log('FRONTEND: Received jobId:', data.jobId);\n            return data.jobId;\n        }\n        throw new Error('No jobId received from init endpoint');\n    }\n    async function startOrchestratorPipeline(id, source) {\n        let flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        console.log('FRONTEND: Requesting backend to START pipeline for jobId:', id);\n        var _flags_scrapeEnabled, _flags_extractEnabled, _flags_retrainModels, _flags_generatePdf;\n        const payload = {\n            source,\n            scrapeEnabled: (_flags_scrapeEnabled = flags.scrapeEnabled) !== null && _flags_scrapeEnabled !== void 0 ? _flags_scrapeEnabled : true,\n            extractEnabled: (_flags_extractEnabled = flags.extractEnabled) !== null && _flags_extractEnabled !== void 0 ? _flags_extractEnabled : true,\n            retrainModels: (_flags_retrainModels = flags.retrainModels) !== null && _flags_retrainModels !== void 0 ? _flags_retrainModels : false,\n            generatePdf: (_flags_generatePdf = flags.generatePdf) !== null && _flags_generatePdf !== void 0 ? _flags_generatePdf : true\n        };\n        const res = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_START_PIPELINE_URL, \"/\").concat(encodeURIComponent(id)), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(payload)\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || \"Failed to start pipeline for jobId \".concat(id));\n        }\n        console.log('FRONTEND: Backend acknowledged pipeline start for jobId:', id);\n    }\n    /** Opens SSE. Resolves once opened OR after a short grace period so we can fallback to polling. */ function openEventStream(id) {\n        let graceMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1200;\n        return new Promise((resolve)=>{\n            if (!id) {\n                console.error('FRONTEND: Cannot open EventSource, jobId is null.');\n                resolve(); // let polling handle it\n                return;\n            }\n            // Close any existing stream before opening a new one\n            closeStream();\n            const url = \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_EVENTS_URL, \"?jobId=\").concat(encodeURIComponent(id));\n            console.log('FRONTEND: Attempting to open EventSource to:', url);\n            const es = new EventSource(url);\n            esRef.current = es;\n            const graceTimer = setTimeout(()=>{\n                if (!openedRef.current) {\n                    console.warn('FRONTEND: SSE did not open within grace period; continuing with polling fallback.');\n                    resolve();\n                }\n            }, graceMs);\n            es.onopen = ()=>{\n                openedRef.current = true;\n                console.log('FRONTEND: SSE connection opened successfully for jobId:', id);\n                clearTimeout(graceTimer);\n                resolve();\n            };\n            es.onmessage = (evt)=>{\n                if (!evt.data) return;\n                try {\n                    const payload = JSON.parse(evt.data);\n                    if (payload.reportUrl) {\n                        setReportUrl(String(payload.reportUrl));\n                        console.log('FRONTEND: Report URL set:', payload.reportUrl);\n                    }\n                    const fn = payload.function;\n                    const st = payload.status;\n                    if (fn && st) {\n                        setSteps((prev)=>prev.map((s)=>{\n                                if (s.fn !== fn) return s;\n                                const map = {\n                                    started: 'in-progress',\n                                    completed: 'completed',\n                                    error: 'error'\n                                };\n                                var _map_st;\n                                return {\n                                    ...s,\n                                    status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                                };\n                            }));\n                        // NEW: Handle final_checking explicitly\n                        if (fn === 'final_checking' && st === 'completed') {\n                            console.log('FRONTEND: Final Validation step completed.');\n                        }\n                    }\n                    if (fn === 'generate_pdf_report' && st === 'completed') {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process complete, closing SSE.');\n                        closeStream();\n                    }\n                    if (st === 'error') {\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process error detected.');\n                    }\n                } catch (e) {\n                // keep-alives or non-JSON; ignore\n                }\n            };\n            es.onerror = (error)=>{\n                console.error('FRONTEND: SSE Error occurred:', error);\n                if (!cancelledRef.current && id) {\n                    pollStatus(id);\n                }\n            };\n        });\n    }\n    async function pollStatus(id) {\n        if (cancelledRef.current || isComplete) return;\n        try {\n            const res = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_STATUS_URL, \"?jobId=\").concat(encodeURIComponent(id)), {\n                cache: 'no-store'\n            });\n            if (res.ok) {\n                const data = await res.json();\n                if (data.reportUrl) setReportUrl(data.reportUrl);\n                if (data.steps) {\n                    setSteps((prev)=>prev.map((s)=>{\n                            const st = data.steps[s.fn];\n                            const map = {\n                                pending: 'pending',\n                                in_progress: 'in-progress',\n                                completed: 'completed',\n                                error: 'error'\n                            };\n                            var _map_st;\n                            return st ? {\n                                ...s,\n                                status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                            } : s;\n                        }));\n                    const done = data.steps['generate_pdf_report'] === 'completed';\n                    if (done) {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Polling detected process complete.');\n                        return;\n                    }\n                    // NEW: detect final_checking completion in polling too\n                    if (data.steps['final_checking'] === 'completed') {\n                        console.log('FRONTEND: Final Validation step completed (via polling).');\n                    }\n                }\n            }\n        } catch (pollError) {\n            console.error('FRONTEND: Error during polling:', pollError);\n        }\n        setTimeout(()=>pollStatus(id), 1000);\n    }\n    async function startFromPdf(file) {\n        resetUI();\n        try {\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            console.log('FRONTEND: Starting PDF upload...');\n            await uploadPdf(file);\n            console.log('FRONTEND: PDF upload complete.');\n            await startOrchestratorPipeline(currentJobId, 'pdf', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromPdf workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function startFromStored() {\n        resetUI();\n        try {\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            await startOrchestratorPipeline(currentJobId, 'stored', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromStored workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function cancel() {\n        console.log('FRONTEND: Cancel requested for jobId:', jobId);\n        cancelledRef.current = true;\n        closeStream();\n        setIsProcessing(false);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        if (jobId) {\n            try {\n                const url = \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE, \"/api/orchestrator/cancel\");\n                const res = await fetch(url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        jobId\n                    })\n                });\n                if (!res.ok) {\n                    const txt = await res.text().catch(()=>'');\n                    throw new Error(txt || 'Cancel request failed');\n                }\n                console.log('FRONTEND: Cancel request sent to backend.');\n            } catch (cancelError) {\n                console.error('FRONTEND: Error sending cancel request:', cancelError);\n            }\n        }\n    }\n    return {\n        steps,\n        isProcessing,\n        isComplete,\n        reportUrl,\n        jobId,\n        startFromPdf,\n        startFromStored,\n        cancel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JlcG9ydC91c2VPcmNoZXN0cmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHFCQUFxQjtxRUFHK0I7QUFTL0I7QUFVckIsU0FBU1UsTUFBTUMsRUFBVTtJQUN2QixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsSUFBTUMsV0FBV0QsR0FBR0Y7QUFDMUM7QUFFQSxTQUFTSSxjQUFjQyxHQUFXO0lBQ2hDLElBQUk7UUFDRiwrQ0FBK0M7UUFDL0MsT0FBTyxJQUFJQyxJQUFJRCxLQUFLRSxRQUFRO0lBQzlCLEVBQUUsVUFBTTtZQUVPVDtRQURiLHlDQUF5QztRQUN6QyxNQUFNVSxPQUFPVixDQUFBQSxvQkFBQUEsZ0RBQVFBLGFBQVJBLGdEQUFRQSx1QkFBUkEsZ0RBQVFBLENBQUVXLE9BQU8sQ0FBQyxRQUFRLGlCQUExQlgsK0JBQUFBLG9CQUFpQztRQUM5QyxNQUFNWSxPQUFPTCxJQUFJTSxVQUFVLENBQUMsT0FBT04sTUFBTSxJQUFRLE9BQUpBO1FBQzdDLE9BQU8sR0FBVUssT0FBUEYsTUFBWSxPQUFMRTtJQUNuQjtBQUNGO0FBRUEsNkVBQTZFLEdBQzdFLGVBQWVFLG1CQUFtQlAsR0FBVztRQUFFUSxRQUFBQSxpRUFBUSxJQUFJQyxVQUFBQSxpRUFBVTtJQUNuRSxNQUFNQyxNQUFNWCxjQUFjQztJQUMxQixJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSUgsT0FBT0csSUFBSztRQUM5QixNQUFNQyxPQUFPLE1BQW9CRCxPQUFkRSxLQUFLQyxHQUFHLElBQUcsS0FBSyxPQUFGSDtRQUNqQyxNQUFNSSxNQUFNTCxJQUFJTSxRQUFRLENBQUMsT0FBTyxNQUFNO1FBQ3RDLE1BQU1DLFdBQVcsR0FBU0YsT0FBTkwsS0FBWUUsT0FBTkcsS0FBVyxPQUFMSDtRQUNoQyxJQUFJO1lBQ0YsSUFBSU0sTUFBTSxNQUFNQyxNQUFNRixVQUFVO2dCQUFFRyxRQUFRO2dCQUFRQyxPQUFPO1lBQVc7WUFDcEUs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QUNBLElBQUksQ0FBQy9CLElBQUlJLEVBQUUsRUFBRTtvQkFDWCxNQUFNaUQsTUFBTSxNQUFNckQsSUFBSXNELElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07b0JBQ3pDLE1BQU0sSUFBSS9DLE1BQU02QyxPQUFPO2dCQUN6QjtnQkFDQVYsUUFBUWMsR0FBRyxDQUFDO1lBQ2QsRUFBRSxPQUFPNkMsYUFBYTtnQkFDcEIzRCxRQUFRQyxLQUFLLENBQUMsMkNBQTJDMEQ7WUFDM0Q7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNML0U7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQW1FO1FBQ0FFO1FBQ0FDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3N0YWwvRG9jdW1lbnRzL1Byb2plY3RzL2N1cnJpY2FsaWduL2Zyb250ZW5kL3NyYy9jb21wb25lbnRzL3JlcG9ydC91c2VPcmNoZXN0cmF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdXNlT3JjaGVzdHJhdG9yLnRzXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIElOSVRJQUxfU1RFUFMsXG4gIE9SQ0hFU1RSQVRPUl9FVkVOVFNfVVJMLFxuICBPUkNIRVNUUkFUT1JfSU5JVF9VUkwsXG4gIE9SQ0hFU1RSQVRPUl9TVEFSVF9QSVBFTElORV9VUkwsXG4gIE9SQ0hFU1RSQVRPUl9TVEFUVVNfVVJMLFxuICBQREZfVVBMT0FEX1VSTCxcbiAgQVBJX0JBU0UsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgT3JjaGVzdHJhdG9yU291cmNlLCBQcm9jZXNzU3RlcCwgU3RlcFN0YXR1cyB9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIFJ1bkZsYWdzID0ge1xuICBzY3JhcGVFbmFibGVkPzogYm9vbGVhbjtcbiAgZXh0cmFjdEVuYWJsZWQ/OiBib29sZWFuO1xuICByZXRyYWluTW9kZWxzPzogYm9vbGVhbjtcbiAgZ2VuZXJhdGVQZGY/OiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgbXMpKTtcbn1cblxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IGFic29sdXRlLCB0aGlzIHdpbGwgc3VjY2VlZC5cbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpLnRvU3RyaW5nKCk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIE1ha2UgaXQgYWJzb2x1dGUgcmVsYXRpdmUgdG8gQVBJX0JBU0UuXG4gICAgY29uc3QgYmFzZSA9IEFQSV9CQVNFPy5yZXBsYWNlKC9cXC8rJC8sICcnKSA/PyAnJztcbiAgICBjb25zdCBwYXRoID0gdXJsLnN0YXJ0c1dpdGgoJy8nKSA/IHVybCA6IGAvJHt1cmx9YDtcbiAgICByZXR1cm4gYCR7YmFzZX0ke3BhdGh9YDtcbiAgfVxufVxuXG4vKiogUHJvYmUgVVJMIHVudGlsIGl0IHJlc3BvbmRzIE9LLiBUcmllcyBIRUFELCBmYWxscyBiYWNrIHRvIEdFVCBpZiBuZWVkZWQuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0VW50aWxSZWFjaGFibGUodXJsOiBzdHJpbmcsIHRyaWVzID0gMTAsIGRlbGF5TXMgPSA1MDApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgYWJzID0gdG9BYnNvbHV0ZVVybCh1cmwpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWVzOyBpKyspIHtcbiAgICBjb25zdCBidXN0ID0gYF90PSR7RGF0ZS5ub3coKX0tJHtpfWA7XG4gICAgY29uc3Qgc2VwID0gYWJzLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gICAgY29uc3QgcHJvYmVVcmwgPSBgJHthYnN9JHtzZXB9JHtidXN0fWA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaChwcm9iZVVybCwgeyBtZXRob2Q6ICdIRUFEJywgY2FjaGU6ICduby1zdG9yZScgfSk7XG4gICAgICBpZiAocmVzLm9rKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gSWYgSEVBRCBub3Qgc3VwcG9ydGVkLCB0cnkgR0VUIHdpdGhvdXQgZG93bmxvYWRpbmcgYm9keVxuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNSB8fCByZXMuc3RhdHVzID09PSA1MDEpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2gocHJvYmVVcmwsIHsgbWV0aG9kOiAnR0VUJywgY2FjaGU6ICduby1zdG9yZScgfSk7XG4gICAgICAgIGlmIChyZXMub2spIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gaWdub3JlIGFuZCByZXRyeVxuICAgIH1cbiAgICBhd2FpdCBzbGVlcChkZWxheU1zKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiBEb3dubG9hZCBhIFVSTCBhcyBhIGZpbGUgd2l0aG91dCBwYWdlIG5hdmlnYXRpb24uICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZFVybEFzRmlsZSh1cmw6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZykge1xuICBjb25zdCBhYnMgPSB0b0Fic29sdXRlVXJsKHVybCk7XG4gIGNvbnN0IGJ1c3QgPSBhYnMuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YWJzfSR7YnVzdH1fZGw9JHtEYXRlLm5vdygpfWAsIHsgY2FjaGU6ICduby1zdG9yZScgfSk7XG4gIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYERvd25sb2FkIGZhaWxlZDogJHtyZXMuc3RhdHVzfWApO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgY29uc3Qgb2JqZWN0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgYS5ocmVmID0gb2JqZWN0VXJsO1xuICBhLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gIGEuY2xpY2soKTtcbiAgYS5yZW1vdmUoKTtcbiAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT3JjaGVzdHJhdG9yKCkge1xuICBjb25zdCBbc3RlcHMsIHNldFN0ZXBzXSA9IHVzZVN0YXRlPFByb2Nlc3NTdGVwW10+KElOSVRJQUxfU1RFUFMpO1xuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNDb21wbGV0ZSwgc2V0SXNDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZXBvcnRVcmwsIHNldFJlcG9ydFVybF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2pvYklkLCBzZXRKb2JJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBlc1JlZiA9IHVzZVJlZjxFdmVudFNvdXJjZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjYW5jZWxsZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBvcGVuZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBkb3dubG9hZFN0YXJ0ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIGNvbnN0IGNsb3NlU3RyZWFtID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBlc1JlZi5jdXJyZW50Py5jbG9zZSgpO1xuICAgIH0gY2F0Y2gge31cbiAgICBlc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICBvcGVuZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IGNsb3NlU3RyZWFtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG5cbiAgLy8gQXV0by1kb3dubG9hZCB3aGVuIHJlcG9ydFVybCBhcnJpdmVzIOKAlCBXSVRIT1VUIG5hdmlnYXRpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFyZXBvcnRVcmwgfHwgZG93bmxvYWRTdGFydGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGRvd25sb2FkU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlYWNoYWJsZSA9IGF3YWl0IHdhaXRVbnRpbFJlYWNoYWJsZShyZXBvcnRVcmwsIDE0LCA1MDApO1xuICAgICAgICBpZiAoIXJlYWNoYWJsZSkgdGhyb3cgbmV3IEVycm9yKCdSZXBvcnQgVVJMIGlzIG5vdCByZWFjaGFibGUgeWV0Jyk7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3RlZCA9IGBhbGlnbm1lbnRfcmVwb3J0XyR7am9iSWQgPz8gRGF0ZS5ub3coKX0ucGRmYDtcbiAgICAgICAgYXdhaXQgZG93bmxvYWRVcmxBc0ZpbGUocmVwb3J0VXJsLCBzdWdnZXN0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBBdXRvLWRvd25sb2FkIGZhaWxlZDonLCBlcnIpO1xuICAgICAgICAvLyBhbGxvdyBtYW51YWwgcmV0cnkgYnkgcmVzZXR0aW5nIHRoZSBmbGFnIGlmIG5lZWRlZFxuICAgICAgICBkb3dubG9hZFN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbcmVwb3J0VXJsLCBqb2JJZF0pO1xuXG4gIGNvbnN0IHJlc2V0VUkgPSAoKSA9PiB7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHNldElzQ29tcGxldGUoZmFsc2UpO1xuICAgIHNldFJlcG9ydFVybChudWxsKTtcbiAgICBzZXRTdGVwcyhJTklUSUFMX1NURVBTLm1hcCgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGVuZGluZycgfSkpKTtcbiAgICBjYW5jZWxsZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGRvd25sb2FkU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGRmKGZpbGU6IEZpbGUpIHtcbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChQREZfVVBMT0FEX1VSTCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogZm9ybSB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHh0IHx8ICdGYWlsZWQgdG8gdXBsb2FkIFBERicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGluaXRPcmNoZXN0cmF0b3JKb2IoKSB7XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBSZXF1ZXN0aW5nIG5ldyBqb2JJZCBmcm9tIGJhY2tlbmQuLi4nKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChPUkNIRVNUUkFUT1JfSU5JVF9VUkwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHR4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHR4dCB8fCAnRmFpbGVkIHRvIGluaXRpYWxpemUgb3JjaGVzdHJhdG9yIGpvYicpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICBpZiAoZGF0YT8uam9iSWQpIHtcbiAgICAgIHNldEpvYklkKFN0cmluZyhkYXRhLmpvYklkKSk7XG4gICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFJlY2VpdmVkIGpvYklkOicsIGRhdGEuam9iSWQpO1xuICAgICAgcmV0dXJuIGRhdGEuam9iSWQgYXMgc3RyaW5nO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGpvYklkIHJlY2VpdmVkIGZyb20gaW5pdCBlbmRwb2ludCcpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRPcmNoZXN0cmF0b3JQaXBlbGluZShcbiAgICBpZDogc3RyaW5nLFxuICAgIHNvdXJjZTogT3JjaGVzdHJhdG9yU291cmNlLFxuICAgIGZsYWdzOiBSdW5GbGFncyA9IHt9XG4gICkge1xuICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUmVxdWVzdGluZyBiYWNrZW5kIHRvIFNUQVJUIHBpcGVsaW5lIGZvciBqb2JJZDonLCBpZCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNjcmFwZUVuYWJsZWQ6IGZsYWdzLnNjcmFwZUVuYWJsZWQgPz8gdHJ1ZSxcbiAgICAgIGV4dHJhY3RFbmFibGVkOiBmbGFncy5leHRyYWN0RW5hYmxlZCA/PyB0cnVlLFxuICAgICAgcmV0cmFpbk1vZGVsczogZmxhZ3MucmV0cmFpbk1vZGVscyA/PyBmYWxzZSxcbiAgICAgIGdlbmVyYXRlUGRmOiBmbGFncy5nZW5lcmF0ZVBkZiA/PyB0cnVlLFxuICAgIH07XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtPUkNIRVNUUkFUT1JfU1RBUlRfUElQRUxJTkVfVVJMfS8ke2VuY29kZVVSSUNvbXBvbmVudChpZCl9YCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0eHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+ICcnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eHQgfHwgYEZhaWxlZCB0byBzdGFydCBwaXBlbGluZSBmb3Igam9iSWQgJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBCYWNrZW5kIGFja25vd2xlZGdlZCBwaXBlbGluZSBzdGFydCBmb3Igam9iSWQ6JywgaWQpO1xuICB9XG5cbiAgLyoqIE9wZW5zIFNTRS4gUmVzb2x2ZXMgb25jZSBvcGVuZWQgT1IgYWZ0ZXIgYSBzaG9ydCBncmFjZSBwZXJpb2Qgc28gd2UgY2FuIGZhbGxiYWNrIHRvIHBvbGxpbmcuICovXG4gIGZ1bmN0aW9uIG9wZW5FdmVudFN0cmVhbShpZD86IHN0cmluZyB8IG51bGwsIGdyYWNlTXMgPSAxMjAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBDYW5ub3Qgb3BlbiBFdmVudFNvdXJjZSwgam9iSWQgaXMgbnVsbC4nKTtcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyBsZXQgcG9sbGluZyBoYW5kbGUgaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbG9zZSBhbnkgZXhpc3Rpbmcgc3RyZWFtIGJlZm9yZSBvcGVuaW5nIGEgbmV3IG9uZVxuICAgICAgY2xvc2VTdHJlYW0oKTtcblxuICAgICAgY29uc3QgdXJsID0gYCR7T1JDSEVTVFJBVE9SX0VWRU5UU19VUkx9P2pvYklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gO1xuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBBdHRlbXB0aW5nIHRvIG9wZW4gRXZlbnRTb3VyY2UgdG86JywgdXJsKTtcbiAgICAgIGNvbnN0IGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgICBlc1JlZi5jdXJyZW50ID0gZXM7XG5cbiAgICAgIGNvbnN0IGdyYWNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFvcGVuZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRlJPTlRFTkQ6IFNTRSBkaWQgbm90IG9wZW4gd2l0aGluIGdyYWNlIHBlcmlvZDsgY29udGludWluZyB3aXRoIHBvbGxpbmcgZmFsbGJhY2suJyk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBncmFjZU1zKTtcblxuICAgICAgZXMub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBvcGVuZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogU1NFIGNvbm5lY3Rpb24gb3BlbmVkIHN1Y2Nlc3NmdWxseSBmb3Igam9iSWQ6JywgaWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQoZ3JhY2VUaW1lcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGVzLm9ubWVzc2FnZSA9IChldnQpID0+IHtcbiAgICAgICAgaWYgKCFldnQuZGF0YSkgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2dC5kYXRhKTtcblxuICAgICAgICAgIGlmIChwYXlsb2FkLnJlcG9ydFVybCkge1xuICAgICAgICAgICAgc2V0UmVwb3J0VXJsKFN0cmluZyhwYXlsb2FkLnJlcG9ydFVybCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBSZXBvcnQgVVJMIHNldDonLCBwYXlsb2FkLnJlcG9ydFVybCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZm46IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBheWxvYWQuZnVuY3Rpb247XG4gICAgICAgICAgY29uc3Qgc3Q6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBheWxvYWQuc3RhdHVzO1xuXG4gICAgICAgICAgaWYgKGZuICYmIHN0KSB7XG4gICAgICAgICAgICBzZXRTdGVwcygocHJldikgPT5cbiAgICAgICAgICAgICAgcHJldi5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocy5mbiAhPT0gZm4pIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZywgU3RlcFN0YXR1cz4gPSB7XG4gICAgICAgICAgICAgICAgICBzdGFydGVkOiAnaW4tcHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGVkOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucywgc3RhdHVzOiBtYXBbc3RdID8/IHMuc3RhdHVzIH07XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBORVc6IEhhbmRsZSBmaW5hbF9jaGVja2luZyBleHBsaWNpdGx5XG4gICAgICAgICAgICBpZiAoZm4gPT09ICdmaW5hbF9jaGVja2luZycgJiYgc3QgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogRmluYWwgVmFsaWRhdGlvbiBzdGVwIGNvbXBsZXRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm4gPT09ICdnZW5lcmF0ZV9wZGZfcmVwb3J0JyAmJiBzdCA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgIHNldElzQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBQcm9jZXNzIGNvbXBsZXRlLCBjbG9zaW5nIFNTRS4nKTtcbiAgICAgICAgICAgIGNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUHJvY2VzcyBlcnJvciBkZXRlY3RlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmVzIG9yIG5vbi1KU09OOyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZXMub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogU1NFIEVycm9yIG9jY3VycmVkOicsIGVycm9yKTtcbiAgICAgICAgaWYgKCFjYW5jZWxsZWRSZWYuY3VycmVudCAmJiBpZCkge1xuICAgICAgICAgIHBvbGxTdGF0dXMoaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcG9sbFN0YXR1cyhpZDogc3RyaW5nKSB7XG4gICAgaWYgKGNhbmNlbGxlZFJlZi5jdXJyZW50IHx8IGlzQ29tcGxldGUpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7T1JDSEVTVFJBVE9SX1NUQVRVU19VUkx9P2pvYklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gLCB7XG4gICAgICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxuICAgICAgfSk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzLmpzb24oKSkgYXMge1xuICAgICAgICAgIHN0ZXBzPzogUmVjb3JkPCdwZW5kaW5nJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdlcnJvcicgfCBzdHJpbmcsIGFueT47XG4gICAgICAgICAgcmVwb3J0VXJsPzogc3RyaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkYXRhLnJlcG9ydFVybCkgc2V0UmVwb3J0VXJsKGRhdGEucmVwb3J0VXJsKTtcblxuICAgICAgICBpZiAoZGF0YS5zdGVwcykge1xuICAgICAgICAgIHNldFN0ZXBzKChwcmV2KSA9PlxuICAgICAgICAgICAgcHJldi5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc3QgPSBkYXRhLnN0ZXBzIVtzLmZuXTtcbiAgICAgICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBTdGVwU3RhdHVzPiA9IHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nOiAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgaW5fcHJvZ3Jlc3M6ICdpbi1wcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ID8geyAuLi5zLCBzdGF0dXM6IG1hcFtzdF0gPz8gcy5zdGF0dXMgfSA6IHM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBkb25lID0gZGF0YS5zdGVwc1snZ2VuZXJhdGVfcGRmX3JlcG9ydCddID09PSAnY29tcGxldGVkJztcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2V0SXNDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFBvbGxpbmcgZGV0ZWN0ZWQgcHJvY2VzcyBjb21wbGV0ZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBORVc6IGRldGVjdCBmaW5hbF9jaGVja2luZyBjb21wbGV0aW9uIGluIHBvbGxpbmcgdG9vXG4gICAgICAgICAgaWYgKGRhdGEuc3RlcHNbJ2ZpbmFsX2NoZWNraW5nJ10gPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IEZpbmFsIFZhbGlkYXRpb24gc3RlcCBjb21wbGV0ZWQgKHZpYSBwb2xsaW5nKS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChwb2xsRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBFcnJvciBkdXJpbmcgcG9sbGluZzonLCBwb2xsRXJyb3IpO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHBvbGxTdGF0dXMoaWQpLCAxMDAwKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RnJvbVBkZihmaWxlOiBGaWxlKSB7XG4gICAgcmVzZXRVSSgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Sm9iSWQgPSBhd2FpdCBpbml0T3JjaGVzdHJhdG9ySm9iKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogT3BlbmluZyBTU0UgKHdpdGggcG9sbGluZyBmYWxsYmFjaykuLi4nKTtcbiAgICAgIGF3YWl0IG9wZW5FdmVudFN0cmVhbShjdXJyZW50Sm9iSWQpO1xuXG4gICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFN0YXJ0aW5nIFBERiB1cGxvYWQuLi4nKTtcbiAgICAgIGF3YWl0IHVwbG9hZFBkZihmaWxlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUERGIHVwbG9hZCBjb21wbGV0ZS4nKTtcblxuICAgICAgYXdhaXQgc3RhcnRPcmNoZXN0cmF0b3JQaXBlbGluZShjdXJyZW50Sm9iSWQsICdwZGYnLCB7XG4gICAgICAgIHNjcmFwZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGV4dHJhY3RFbmFibGVkOiB0cnVlLFxuICAgICAgICBnZW5lcmF0ZVBkZjogdHJ1ZSxcbiAgICAgICAgcmV0cmFpbk1vZGVsczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgcG9sbFN0YXR1cyhjdXJyZW50Sm9iSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogRXJyb3IgaW4gc3RhcnRGcm9tUGRmIHdvcmtmbG93OicsIGVycm9yKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICBjbG9zZVN0cmVhbSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RnJvbVN0b3JlZCgpIHtcbiAgICByZXNldFVJKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRKb2JJZCA9IGF3YWl0IGluaXRPcmNoZXN0cmF0b3JKb2IoKTtcblxuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBPcGVuaW5nIFNTRSAod2l0aCBwb2xsaW5nIGZhbGxiYWNrKS4uLicpO1xuICAgICAgYXdhaXQgb3BlbkV2ZW50U3RyZWFtKGN1cnJlbnRKb2JJZCk7XG5cbiAgICAgIGF3YWl0IHN0YXJ0T3JjaGVzdHJhdG9yUGlwZWxpbmUoY3VycmVudEpvYklkLCAnc3RvcmVkJywge1xuICAgICAgICBzY3JhcGVFbmFibGVkOiB0cnVlLFxuICAgICAgICBleHRyYWN0RW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZ2VuZXJhdGVQZGY6IHRydWUsXG4gICAgICAgIHJldHJhaW5Nb2RlbHM6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIHBvbGxTdGF0dXMoY3VycmVudEpvYklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRlJPTlRFTkQ6IEVycm9yIGluIHN0YXJ0RnJvbVN0b3JlZCB3b3JrZmxvdzonLCBlcnJvcik7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgY2xvc2VTdHJlYW0oKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBDYW5jZWwgcmVxdWVzdGVkIGZvciBqb2JJZDonLCBqb2JJZCk7XG4gICAgY2FuY2VsbGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIGNsb3NlU3RyZWFtKCk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICBzZXRTdGVwcyhJTklUSUFMX1NURVBTLm1hcCgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGVuZGluZycgfSkpKTtcblxuICAgIGlmIChqb2JJZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0V9L2FwaS9vcmNoZXN0cmF0b3IvY2FuY2VsYDtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBqb2JJZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR4dCB8fCAnQ2FuY2VsIHJlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBDYW5jZWwgcmVxdWVzdCBzZW50IHRvIGJhY2tlbmQuJyk7XG4gICAgICB9IGNhdGNoIChjYW5jZWxFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogRXJyb3Igc2VuZGluZyBjYW5jZWwgcmVxdWVzdDonLCBjYW5jZWxFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGVwcyxcbiAgICBpc1Byb2Nlc3NpbmcsXG4gICAgaXNDb21wbGV0ZSxcbiAgICByZXBvcnRVcmwsXG4gICAgam9iSWQsXG4gICAgc3RhcnRGcm9tUGRmLFxuICAgIHN0YXJ0RnJvbVN0b3JlZCxcbiAgICBjYW5jZWwsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJJTklUSUFMX1NURVBTIiwiT1JDSEVTVFJBVE9SX0VWRU5UU19VUkwiLCJPUkNIRVNUUkFUT1JfSU5JVF9VUkwiLCJPUkNIRVNUUkFUT1JfU1RBUlRfUElQRUxJTkVfVVJMIiwiT1JDSEVTVFJBVE9SX1NUQVRVU19VUkwiLCJQREZfVVBMT0FEX1VSTCIsIkFQSV9CQVNFIiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInRvQWJzb2x1dGVVcmwiLCJ1cmwiLCJVUkwiLCJ0b1N0cmluZyIsImJhc2UiLCJyZXBsYWNlIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJ3YWl0VW50aWxSZWFjaGFibGUiLCJ0cmllcyIsImRlbGF5TXMiLCJhYnMiLCJpIiwiYnVzdCIsIkRhdGUiLCJub3ciLCJzZXAiLCJpbmNsdWRlcyIsInByb2JlVXJsIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsIm9rIiwic3RhdHVzIiwiZG93bmxvYWRVcmxBc0ZpbGUiLCJmaWxlbmFtZSIsIkVycm9yIiwiYmxvYiIsIm9iamVjdFVybCIsImNyZWF0ZU9iamVjdFVSTCIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZSIsInJldm9rZU9iamVjdFVSTCIsInVzZU9yY2hlc3RyYXRvciIsInN0ZXBzIiwic2V0U3RlcHMiLCJpc1Byb2Nlc3NpbmciLCJzZXRJc1Byb2Nlc3NpbmciLCJpc0NvbXBsZXRlIiwic2V0SXNDb21wbGV0ZSIsInJlcG9ydFVybCIsInNldFJlcG9ydFVybCIsImpvYklkIiwic2V0Sm9iSWQiLCJlc1JlZiIsImNhbmNlbGxlZFJlZiIsIm9wZW5lZFJlZiIsImRvd25sb2FkU3RhcnRlZFJlZiIsImNsb3NlU3RyZWFtIiwiY3VycmVudCIsImNsb3NlIiwicmVhY2hhYmxlIiwic3VnZ2VzdGVkIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwicmVzZXRVSSIsIm1hcCIsInMiLCJ1cGxvYWRQZGYiLCJmaWxlIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwidHh0IiwidGV4dCIsImNhdGNoIiwiaW5pdE9yY2hlc3RyYXRvckpvYiIsImxvZyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImpzb24iLCJTdHJpbmciLCJzdGFydE9yY2hlc3RyYXRvclBpcGVsaW5lIiwiaWQiLCJzb3VyY2UiLCJmbGFncyIsInBheWxvYWQiLCJzY3JhcGVFbmFibGVkIiwiZXh0cmFjdEVuYWJsZWQiLCJyZXRyYWluTW9kZWxzIiwiZ2VuZXJhdGVQZGYiLCJlbmNvZGVVUklDb21wb25lbnQiLCJvcGVuRXZlbnRTdHJlYW0iLCJncmFjZU1zIiwicmVzb2x2ZSIsImVzIiwiRXZlbnRTb3VyY2UiLCJncmFjZVRpbWVyIiwid2FybiIsIm9ub3BlbiIsImNsZWFyVGltZW91dCIsIm9ubWVzc2FnZSIsImV2dCIsInBhcnNlIiwiZm4iLCJmdW5jdGlvbiIsInN0IiwicHJldiIsInN0YXJ0ZWQiLCJjb21wbGV0ZWQiLCJvbmVycm9yIiwicG9sbFN0YXR1cyIsInBlbmRpbmciLCJpbl9wcm9ncmVzcyIsImRvbmUiLCJwb2xsRXJyb3IiLCJzdGFydEZyb21QZGYiLCJjdXJyZW50Sm9iSWQiLCJzdGFydEZyb21TdG9yZWQiLCJjYW5jZWwiLCJjYW5jZWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/report/useOrchestrator.ts\n"));

/***/ })

});