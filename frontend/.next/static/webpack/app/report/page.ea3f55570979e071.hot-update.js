"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/report/page",{

/***/ "(app-pages-browser)/./src/components/report/useOrchestrator.ts":
/*!**************************************************!*\
  !*** ./src/components/report/useOrchestrator.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOrchestrator: () => (/* binding */ useOrchestrator)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./src/components/report/constants.ts\");\n// src/components/report/useOrchestrator.ts\n/* __next_internal_client_entry_do_not_use__ useOrchestrator auto */ \n\nfunction sleep(ms) {\n    return new Promise((r)=>setTimeout(r, ms));\n}\nfunction toAbsoluteUrl(url) {\n    try {\n        return new URL(url).toString();\n    } catch (e) {\n        var _API_BASE_replace;\n        const base = (_API_BASE_replace = _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === null || _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === void 0 ? void 0 : _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE.replace(/\\/+$/, '')) !== null && _API_BASE_replace !== void 0 ? _API_BASE_replace : '';\n        const path = url.startsWith('/') ? url : \"/\".concat(url);\n        return \"\".concat(base).concat(path);\n    }\n}\n/** Probe URL until it responds OK. Tries HEAD, falls back to GET if needed. */ async function waitUntilReachable(url) {\n    let tries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, delayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500;\n    const abs = toAbsoluteUrl(url);\n    for(let i = 0; i < tries; i++){\n        const bust = \"_t=\".concat(Date.now(), \"-\").concat(i);\n        const sep = abs.includes('?') ? '&' : '?';\n        const probeUrl = \"\".concat(abs).concat(sep).concat(bust);\n        try {\n            let res = await fetch(probeUrl, {\n                method: 'HEAD',\n                cache: 'no-store'\n            });\n            if (res.ok) return true;\n            if (res.status === 405 || res.status === 501) {\n                res = await fetch(probeUrl, {\n                    method: 'GET',\n                    cache: 'no-store'\n                });\n                if (res.ok) return true;\n            }\n        } catch (e) {\n        // ignore and retry\n        }\n        await sleep(delayMs);\n    }\n    return false;\n}\n/** Download a URL as a file without page navigation. */ async function downloadUrlAsFile(url, filename) {\n    const abs = toAbsoluteUrl(url);\n    const bust = abs.includes('?') ? '&' : '?';\n    const res = await fetch(\"\".concat(abs).concat(bust, \"_dl=\").concat(Date.now()), {\n        cache: 'no-store'\n    });\n    if (!res.ok) throw new Error(\"Download failed: \".concat(res.status));\n    const blob = await res.blob();\n    const objectUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = objectUrl;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(objectUrl);\n}\nfunction useOrchestrator() {\n    const [steps, setSteps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS);\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [reportUrl, setReportUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [jobId, setJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // OPTIONAL: preview what scan-pdf parsed\n    const [parsedRows, setParsedRows] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const esRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const cancelledRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const openedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const downloadStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const closeStream = ()=>{\n        try {\n            var _esRef_current;\n            (_esRef_current = esRef.current) === null || _esRef_current === void 0 ? void 0 : _esRef_current.close();\n        } catch (e) {}\n        esRef.current = null;\n        openedRef.current = false;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            return ({\n                \"useOrchestrator.useEffect\": ()=>closeStream()\n            })[\"useOrchestrator.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], []);\n    // Auto-download when reportUrl arrives â€” WITHOUT navigating\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            ({\n                \"useOrchestrator.useEffect\": async ()=>{\n                    if (!reportUrl || downloadStartedRef.current) return;\n                    downloadStartedRef.current = true;\n                    try {\n                        const reachable = await waitUntilReachable(reportUrl, 14, 500);\n                        if (!reachable) throw new Error('Report URL is not reachable yet');\n                        const suggested = \"alignment_report_\".concat(jobId !== null && jobId !== void 0 ? jobId : Date.now(), \".pdf\");\n                        await downloadUrlAsFile(reportUrl, suggested);\n                    } catch (err) {\n                        console.error('FRONTEND: Auto-download failed:', err);\n                        downloadStartedRef.current = false;\n                    }\n                }\n            })[\"useOrchestrator.useEffect\"]();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], [\n        reportUrl,\n        jobId\n    ]);\n    const resetUI = ()=>{\n        setIsProcessing(true);\n        setIsComplete(false);\n        setReportUrl(null);\n        setParsedRows(null);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        cancelledRef.current = false;\n        downloadStartedRef.current = false;\n    };\n    /**\n   * Upload the PDF to the backend scan endpoint.\n   * IMPORTANT: backend expects field name 'pdf' => async def scan_pdf_endpoint(pdf: UploadFile = File(...))\n   * Returns the JSON body so callers can read parsed_rows if desired.\n   */ async function uploadPdf(file) {\n        const form = new FormData();\n        form.append('pdf', file); // <-- FIX: must be 'pdf', not 'file'\n        const url = toAbsoluteUrl(_constants__WEBPACK_IMPORTED_MODULE_1__.PDF_UPLOAD_URL); // ensure absolute URL\n        const res = await fetch(url, {\n            method: 'POST',\n            body: form\n        });\n        const text = await res.text().catch(()=>'');\n        if (!res.ok) {\n            // Typical FastAPI error body shape: {\"detail\": \"...\"}\n            let detail = '';\n            try {\n                const j = JSON.parse(text);\n                detail = (j === null || j === void 0 ? void 0 : j.detail) || '';\n            } catch (e) {}\n            const explain = detail || text || \"Upload failed (\".concat(res.status, \")\");\n            throw new Error(\"scan-pdf error: \".concat(explain));\n        }\n        // Parse success body\n        let data = {};\n        try {\n            data = JSON.parse(text || '{}');\n        } catch (e) {\n            throw new Error('scan-pdf returned non-JSON response');\n        }\n        const rows = Array.isArray(data === null || data === void 0 ? void 0 : data.parsed_rows) ? data.parsed_rows : [];\n        setParsedRows(rows);\n        return data;\n    }\n    async function initOrchestratorJob() {\n        console.log('FRONTEND: Requesting new jobId from backend...');\n        const res = await fetch(toAbsoluteUrl(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_INIT_URL), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({})\n        });\n        const txt = await res.text().catch(()=>'');\n        if (!res.ok) {\n            throw new Error(txt || 'Failed to initialize orchestrator job');\n        }\n        const data = txt ? JSON.parse(txt) : {};\n        if (data === null || data === void 0 ? void 0 : data.jobId) {\n            setJobId(String(data.jobId));\n            console.log('FRONTEND: Received jobId:', data.jobId);\n            return String(data.jobId);\n        }\n        throw new Error('No jobId received from init endpoint');\n    }\n    async function startOrchestratorPipeline(id, source) {\n        let flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        console.log('FRONTEND: Requesting backend to START pipeline for jobId:', id);\n        var _flags_scrapeEnabled, _flags_extractEnabled, _flags_retrainModels, _flags_generatePdf;\n        const payload = {\n            source,\n            scrapeEnabled: (_flags_scrapeEnabled = flags.scrapeEnabled) !== null && _flags_scrapeEnabled !== void 0 ? _flags_scrapeEnabled : true,\n            extractEnabled: (_flags_extractEnabled = flags.extractEnabled) !== null && _flags_extractEnabled !== void 0 ? _flags_extractEnabled : true,\n            retrainModels: (_flags_retrainModels = flags.retrainModels) !== null && _flags_retrainModels !== void 0 ? _flags_retrainModels : false,\n            generatePdf: (_flags_generatePdf = flags.generatePdf) !== null && _flags_generatePdf !== void 0 ? _flags_generatePdf : true\n        };\n        const res = await fetch(toAbsoluteUrl(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_START_PIPELINE_URL, \"/\").concat(encodeURIComponent(id))), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(payload)\n        });\n        const txt = await res.text().catch(()=>'');\n        if (!res.ok) {\n            throw new Error(txt || \"Failed to start pipeline for jobId \".concat(id));\n        }\n        console.log('FRONTEND: Backend acknowledged pipeline start for jobId:', id);\n    }\n    /** Opens SSE. Resolves once opened OR after a short grace period so we can fallback to polling. */ function openEventStream(id) {\n        let graceMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1200;\n        return new Promise((resolve)=>{\n            if (!id) {\n                console.error('FRONTEND: Cannot open EventSource, jobId is null.');\n                resolve(); // let polling handle it\n                return;\n            }\n            closeStream();\n            const url = \"\".concat(toAbsoluteUrl(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_EVENTS_URL), \"?jobId=\").concat(encodeURIComponent(id));\n            console.log('FRONTEND: Attempting to open EventSource to:', url);\n            const es = new EventSource(url);\n            esRef.current = es;\n            const graceTimer = setTimeout(()=>{\n                if (!openedRef.current) {\n                    console.warn('FRONTEND: SSE did not open within grace period; continuing with polling fallback.');\n                    resolve();\n                }\n            }, graceMs);\n            es.onopen = ()=>{\n                openedRef.current = true;\n                console.log('FRONTEND: SSE connection opened successfully for jobId:', id);\n                clearTimeout(graceTimer);\n                resolve();\n            };\n            es.onmessage = (evt)=>{\n                if (!evt.data) return;\n                try {\n                    const payload = JSON.parse(evt.data);\n                    // --- Handle explicit pipeline error events ---\n                    if ((payload === null || payload === void 0 ? void 0 : payload.type) === 'error') {\n                        console.error('PIPELINE ERROR:', payload.failed_at || payload.function, payload.error);\n                        const failedFn = payload.failed_at || payload.function;\n                        if (failedFn) {\n                            setSteps((prev)=>prev.map((s)=>s.fn === failedFn ? {\n                                        ...s,\n                                        status: 'error'\n                                    } : s));\n                        }\n                        setIsProcessing(false);\n                        closeStream();\n                        if (!cancelledRef.current && id) pollStatus(id);\n                        return;\n                    }\n                    if (payload.reportUrl) {\n                        setReportUrl(String(payload.reportUrl));\n                        console.log('FRONTEND: Report URL set:', payload.reportUrl);\n                    }\n                    const fn = payload.function;\n                    const st = payload.status;\n                    if (fn && st) {\n                        setSteps((prev)=>prev.map((s)=>{\n                                if (s.fn !== fn) return s;\n                                const map = {\n                                    started: 'in-progress',\n                                    completed: 'completed',\n                                    error: 'error'\n                                };\n                                var _map_st;\n                                return {\n                                    ...s,\n                                    status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                                };\n                            }));\n                        if (fn === 'final_checking' && st === 'completed') {\n                            console.log('FRONTEND: Final Validation step completed.');\n                        }\n                    }\n                    if (fn === 'generate_pdf_report' && st === 'completed') {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process complete, closing SSE.');\n                        closeStream();\n                    }\n                    if (st === 'error') {\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process error detected.');\n                    }\n                } catch (e) {\n                // keep-alives or non-JSON; ignore\n                }\n            };\n            es.onerror = (error)=>{\n                console.error('FRONTEND: SSE Error occurred:', error);\n                if (!cancelledRef.current && id) {\n                    pollStatus(id);\n                }\n            };\n        });\n    }\n    async function pollStatus(id) {\n        if (cancelledRef.current || isComplete) return;\n        try {\n            const res = await fetch(\"\".concat(toAbsoluteUrl(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_STATUS_URL), \"?jobId=\").concat(encodeURIComponent(id)), {\n                cache: 'no-store'\n            });\n            if (res.ok) {\n                const data = await res.json();\n                if (data.reportUrl) setReportUrl(data.reportUrl);\n                if (data.steps) {\n                    setSteps((prev)=>prev.map((s)=>{\n                            const st = data.steps[s.fn];\n                            const map = {\n                                pending: 'pending',\n                                in_progress: 'in-progress',\n                                completed: 'completed',\n                                error: 'error'\n                            };\n                            var _map_st;\n                            return st ? {\n                                ...s,\n                                status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                            } : s;\n                        }));\n                    const done = data.steps['generate_pdf_report'] === 'completed';\n                    if (done) {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Polling detected process complete.');\n                        return;\n                    }\n                    if (data.steps['final_checking'] === 'completed') {\n                        console.log('FRONTEND: Final Validation step completed (via polling).');\n                    }\n                }\n            }\n        } catch (pollError) {\n            console.error('FRONTEND: Error during polling:', pollError);\n        }\n        setTimeout(()=>pollStatus(id), 1000);\n    }\n    async function startFromPdf(file) {\n        resetUI();\n        try {\n            // 1) Upload & parse PDF first so courses are in DB before pipeline begins\n            console.log('FRONTEND: Starting PDF upload to scan endpoint...');\n            await uploadPdf(file);\n            console.log('FRONTEND: PDF upload complete.');\n            // 2) Init job and open stream\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            // 3) Start the pipeline\n            await startOrchestratorPipeline(currentJobId, 'pdf', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            // 4) Poll status as a fallback alongside SSE\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromPdf workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function startFromStored() {\n        resetUI();\n        try {\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            await startOrchestratorPipeline(currentJobId, 'stored', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromStored workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function cancel() {\n        console.log('FRONTEND: Cancel requested for jobId:', jobId);\n        cancelledRef.current = true;\n        closeStream();\n        setIsProcessing(false);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        if (jobId) {\n            try {\n                const url = toAbsoluteUrl('/api/orchestrator/cancel');\n                const res = await fetch(url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        jobId\n                    })\n                });\n                if (!res.ok) {\n                    const txt = await res.text().catch(()=>'');\n                    throw new Error(txt || 'Cancel request failed');\n                }\n                console.log('FRONTEND: Cancel request sent to backend.');\n            } catch (cancelError) {\n                console.error('FRONTEND: Error sending cancel request:', cancelError);\n            }\n        }\n    }\n    return {\n        steps,\n        isProcessing,\n        isComplete,\n        reportUrl,\n        jobId,\n        parsedRows,\n        startFromPdf,\n        startFromStored,\n        cancel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JlcG9ydC91c2VPcmNoZXN0cmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDJDQUEyQztxRUFHUztBQVMvQjtBQVVyQixTQUFTVSxNQUFNQyxFQUFVO0lBQ3ZCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxJQUFNQyxXQUFXRCxHQUFHRjtBQUMxQztBQUVBLFNBQVNJLGNBQWNDLEdBQVc7SUFDaEMsSUFBSTtRQUNGLE9BQU8sSUFBSUMsSUFBSUQsS0FBS0UsUUFBUTtJQUM5QixFQUFFLFVBQU07WUFDT1Q7UUFBYixNQUFNVSxPQUFPVixDQUFBQSxvQkFBQUEsZ0RBQVFBLGFBQVJBLGdEQUFRQSx1QkFBUkEsZ0RBQVFBLENBQUVXLE9BQU8sQ0FBQyxRQUFRLGlCQUExQlgsK0JBQUFBLG9CQUFpQztRQUM5QyxNQUFNWSxPQUFPTCxJQUFJTSxVQUFVLENBQUMsT0FBT04sTUFBTSxJQUFRLE9BQUpBO1FBQzdDLE9BQU8sR0FBVUssT0FBUEYsTUFBWSxPQUFMRTtJQUNuQjtBQUNGO0FBRUEsNkVBQTZFLEdBQzdFLGVBQWVFLG1CQUFtQlAsR0FBVztRQUFFUSxRQUFBQSxpRUFBUSxJQUFJQyxVQUFBQSxpRUFBVTtJQUNuRSxNQUFNQyxNQUFNWCxjQUFjQztJQUMxQixJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSUgsT0FBT0csSUFBSztRQUM5QixNQUFNQyxPQUFPLE1BQW9CRCxPQUFkRSxLQUFLQyxHQUFHLElBQUcsS0FBSyxPQUFGSDtRQUNqQyxNQUFNSSxNQUFNTCxJQUFJTSxRQUFRLENBQUMsT0FBTyxNQUFNO1FBQ3RDLE1BQU1DLFdBQVcsR0FBU0YsT0FBTkwsS0FBWUUsT0FBTkcsS0FBVyxPQUFMSDtRQUNoQyxJQUFJO1lBQ0YsSUFBSU0sTUFBTSxNQUFNQyxNQUFNRixVQUFVO2dCQUFFRyxRQUFRO2dCQUFRQyxPQUFPO1lBQVc7WUFDcEUsSUFBSUgsSUFBSUksRUFBRSxFQUFFLE9BQU87WUFFbkIsSUFBSUosSUFBSUssTUFBTSxLQUFLLE9BQU9MLElBQUlLLE1BQU0sS0FBSyxLQUFLO2dCQUM1Q0wsTUFBTSxNQUFNQyxNQUFNRixVQUFVO29CQUFFRyxRQUFRO29CQUFPQyxPQUFPO2dCQUFXO2dCQUMvRCxJQUFJSCxJQUFJSSxFQUFFLEVBQUUsT0FBTztZQUNyQjtRQUNGLEVBQUUsVUFBTTtRQUNOLG1CQUFtQjtRQUNyQjtRQUNBLE1BQU01QixNQUFNZTtJQUNkO0lBQ0EsT0FBTztBQUNUO0FBRUEsc0RBQXNELEdBQ3RELGVBQWVlLGtCQUFrQnhCLEdBQVcsRUFBRXlCLFFBQWdCO0lBQzVELE1BQU1mLE1BQU1YLGNBQWNDO0lBQzFCLE1BQU1ZLE9BQU9GLElBQUlNLFFBQVEsQ0FBQyxPQUFPLE1BQU07SUFDdkMsTUFBTUUsTUFBTSxNQUFNQyxNQUFNLEdBQVNQLE9BQU5GLEtBQWlCRyxPQUFYRCxNQUFLLFFBQWlCLE9BQVhDLEtBQUtDLEdBQUcsS0FBTTtRQUFFTyxPQUFPO0lBQVc7SUFDOUUsSUFBSSxDQUFDSCxJQUFJSSxFQUFFLEVBQUUsTUFBTSxJQUFJSSxNQUFNLG9CQUErQixPQUFYUixJQUFJSyxNQUFNO0lBQzNELE1BQU1JLE9BQU8sTUFBTVQsSUFBSVMsSUFBSTtJQUMzQixNQUFNQyxZQUFZM0IsSUFBSTRCLGVBQWUsQ0FBQ0Y7SUFDdEMsTUFBTUcsSUFBSUMsU0FBU0MsYUFBYSxDQUFDO0lBQ2pDRixFQUFFRyxJQUFJLEdBQUdMO0lBQ1RFLEVBQUVJLFFBQVEsR0FBR1Q7SUFDYk0sU0FBU0ksSUFBSSxDQUFDQyxXQUFXLENBQUNOO0lBQzFCQSxFQUFFTyxLQUFLO0lBQ1BQLEVBQUVRLE1BQU07SUFDUnJDLElBQUlzQyxlQUFlLENBQUNYO0FBQ3RCO0FBRU8sU0FBU1k7SUFDZCxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3hELCtDQUFRQSxDQUFnQkMscURBQWFBO0lBQy9ELE1BQU0sQ0FBQ3dELGNBQWNDLGdCQUFnQixHQUFHMUQsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDMkQsWUFBWUMsY0FBYyxHQUFHNUQsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDNkQsV0FBV0MsYUFBYSxHQUFHOUQsK0NBQVFBLENBQWdCO0lBQzFELE1BQU0sQ0FBQytELE9BQU9DLFNBQVMsR0FBR2hFLCtDQUFRQSxDQUFnQjtJQUVsRCx5Q0FBeUM7SUFDekMsTUFBTSxDQUFDaUUsWUFBWUMsY0FBYyxHQUFHbEUsK0NBQVFBLENBQWU7SUFFM0QsTUFBTW1FLFFBQVFwRSw2Q0FBTUEsQ0FBcUI7SUFDekMsTUFBTXFFLGVBQWVyRSw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNc0UsWUFBWXRFLDZDQUFNQSxDQUFDO0lBQ3pCLE1BQU11RSxxQkFBcUJ2RSw2Q0FBTUEsQ0FBQztJQUVsQyxNQUFNd0UsY0FBYztRQUNsQixJQUFJO2dCQUNGSjthQUFBQSxpQkFBQUEsTUFBTUssT0FBTyxjQUFiTCxxQ0FBQUEsZUFBZU0sS0FBSztRQUN0QixFQUFFLFVBQU0sQ0FBQztRQUNUTixNQUFNSyxPQUFPLEdBQUc7UUFDaEJILFVBQVVHLE9BQU8sR0FBRztJQUN0QjtJQUVBMUUsZ0RBQVNBO3FDQUFDO1lBQ1I7NkNBQU8sSUFBTXlFOztRQUNiLHVEQUF1RDtRQUN6RDtvQ0FBRyxFQUFFO0lBRUwsNERBQTREO0lBQzVEekUsZ0RBQVNBO3FDQUFDO1lBQ1I7NkNBQUM7b0JBQ0MsSUFBSSxDQUFDK0QsYUFBYVMsbUJBQW1CRSxPQUFPLEVBQUU7b0JBQzlDRixtQkFBbUJFLE9BQU8sR0FBRztvQkFDN0IsSUFBSTt3QkFDRixNQUFNRSxZQUFZLE1BQU1yRCxtQkFBbUJ3QyxXQUFXLElBQUk7d0JBQzFELElBQUksQ0FBQ2EsV0FBVyxNQUFNLElBQUlsQyxNQUFNO3dCQUNoQyxNQUFNbUMsWUFBWSxvQkFBd0MsT0FBcEJaLGtCQUFBQSxtQkFBQUEsUUFBU3BDLEtBQUtDLEdBQUcsSUFBRzt3QkFDMUQsTUFBTVUsa0JBQWtCdUIsV0FBV2M7b0JBQ3JDLEVBQUUsT0FBT0MsS0FBSzt3QkFDWkMsUUFBUUMsS0FBSyxDQUFDLG1DQUFtQ0Y7d0JBQ2pETixtQkFBbUJFLE9BQU8sR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0EsdURBQXVEO1FBQ3pEO29DQUFHO1FBQUNYO1FBQVdFO0tBQU07SUFFckIsTUFBTWdCLFVBQVU7UUFDZHJCLGdCQUFnQjtRQUNoQkUsY0FBYztRQUNkRSxhQUFhO1FBQ2JJLGNBQWM7UUFDZFYsU0FBU3ZELHFEQUFhQSxDQUFDK0UsR0FBRyxDQUFDLENBQUNDLElBQU87Z0JBQUUsR0FBR0EsQ0FBQztnQkFBRTVDLFFBQVE7WUFBVTtRQUM3RCtCLGFBQWFJLE9BQU8sR0FBRztRQUN2QkYsbUJBQW1CRSxPQUFPLEdBQUc7SUFDL0I7SUFFQTs7OztHQUlDLEdBQ0QsZUFBZVUsVUFBVUMsSUFBVTtRQUNqQyxNQUFNQyxPQUFPLElBQUlDO1FBQ2pCRCxLQUFLRSxNQUFNLENBQUMsT0FBT0gsT0FBTyxxQ0FBcUM7UUFDL0QsTUFBTXJFLE1BQU1ELGNBQWNQLHNEQUFjQSxHQUFHLHNCQUFzQjtRQUVqRSxNQUFNMEIsTUFBTSxNQUFNQyxNQUFNbkIsS0FBSztZQUFFb0IsUUFBUTtZQUFRZSxNQUFNbUM7UUFBSztRQUMxRCxNQUFNRyxPQUFPLE1BQU12RCxJQUFJdUQsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTTtRQUMxQyxJQUFJLENBQUN4RCxJQUFJSSxFQUFFLEVBQUU7WUFDWCxzREFBc0Q7WUFDdEQsSUFBSXFELFNBQVM7WUFDYixJQUFJO2dCQUNGLE1BQU1DLElBQUlDLEtBQUtDLEtBQUssQ0FBQ0w7Z0JBQ3JCRSxTQUFTQyxDQUFBQSxjQUFBQSx3QkFBQUEsRUFBR0QsTUFBTSxLQUFJO1lBQ3hCLEVBQUUsVUFBTSxDQUFDO1lBQ1QsTUFBTUksVUFBVUosVUFBVUYsUUFBUSxrQkFBNkIsT0FBWHZELElBQUlLLE1BQU0sRUFBQztZQUMvRCxNQUFNLElBQUlHLE1BQU0sbUJBQTJCLE9BQVJxRDtRQUNyQztRQUVBLHFCQUFxQjtRQUNyQixJQUFJQyxPQUFZLENBQUM7UUFDakIsSUFBSTtZQUNGQSxPQUFPSCxLQUFLQyxLQUFLLENBQUNMLFFBQVE7UUFDNUIsRUFBRSxVQUFNO1lBQ04sTUFBTSxJQUFJL0MsTUFBTTtRQUNsQjtRQUNBLE1BQU11RCxPQUFPQyxNQUFNQyxPQUFPLENBQUNILGlCQUFBQSwyQkFBQUEsS0FBTUksV0FBVyxJQUFJSixLQUFLSSxXQUFXLEdBQUcsRUFBRTtRQUNyRWhDLGNBQWM2QjtRQUNkLE9BQU9EO0lBQ1Q7SUFFQSxlQUFlSztRQUNidEIsUUFBUXVCLEdBQUcsQ0FBQztRQUNaLE1BQU1wRSxNQUFNLE1BQU1DLE1BQU1wQixjQUFjViw2REFBcUJBLEdBQUc7WUFDNUQrQixRQUFRO1lBQ1JtRSxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q3BELE1BQU0wQyxLQUFLVyxTQUFTLENBQUMsQ0FBQztRQUN4QjtRQUNBLE1BQU1DLE1BQU0sTUFBTXZFLElBQUl1RCxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFNO1FBQ3pDLElBQUksQ0FBQ3hELElBQUlJLEVBQUUsRUFBRTtZQUNYLE1BQU0sSUFBSUksTUFBTStELE9BQU87UUFDekI7UUFDQSxNQUFNVCxPQUFRUyxNQUFNWixLQUFLQyxLQUFLLENBQUNXLE9BQU8sQ0FBQztRQUN2QyxJQUFJVCxpQkFBQUEsMkJBQUFBLEtBQU0vQixLQUFLLEVBQUU7WUFDZkMsU0FBU3dDLE9BQU9WLEtBQUsvQixLQUFLO1lBQzFCYyxRQUFRdUIsR0FBRyxDQUFDLDZCQUE2Qk4sS0FBSy9CLEtBQUs7WUFDbkQsT0FBT3lDLE9BQU9WLEtBQUsvQixLQUFLO1FBQzFCO1FBQ0EsTUFBTSxJQUFJdkIsTUFBTTtJQUNsQjtJQUVBLGVBQWVpRSwwQkFDYkMsRUFBVSxFQUNWQyxNQUEwQjtZQUMxQkMsUUFBQUEsaUVBQWtCLENBQUM7UUFFbkIvQixRQUFRdUIsR0FBRyxDQUFDLDZEQUE2RE07WUFHeERFLHNCQUNDQSx1QkFDREEsc0JBQ0ZBO1FBTGYsTUFBTUMsVUFBVTtZQUNkRjtZQUNBRyxlQUFlRixDQUFBQSx1QkFBQUEsTUFBTUUsYUFBYSxjQUFuQkYsa0NBQUFBLHVCQUF1QjtZQUN0Q0csZ0JBQWdCSCxDQUFBQSx3QkFBQUEsTUFBTUcsY0FBYyxjQUFwQkgsbUNBQUFBLHdCQUF3QjtZQUN4Q0ksZUFBZUosQ0FBQUEsdUJBQUFBLE1BQU1JLGFBQWEsY0FBbkJKLGtDQUFBQSx1QkFBdUI7WUFDdENLLGFBQWFMLENBQUFBLHFCQUFBQSxNQUFNSyxXQUFXLGNBQWpCTCxnQ0FBQUEscUJBQXFCO1FBQ3BDO1FBRUEsTUFBTTVFLE1BQU0sTUFBTUMsTUFDaEJwQixjQUFjLEdBQXNDcUcsT0FBbkM5Ryx1RUFBK0JBLEVBQUMsS0FBMEIsT0FBdkI4RyxtQkFBbUJSLE9BQ3ZFO1lBQ0V4RSxRQUFRO1lBQ1JtRSxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q3BELE1BQU0wQyxLQUFLVyxTQUFTLENBQUNPO1FBQ3ZCO1FBRUYsTUFBTU4sTUFBTSxNQUFNdkUsSUFBSXVELElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07UUFDekMsSUFBSSxDQUFDeEQsSUFBSUksRUFBRSxFQUFFO1lBQ1gsTUFBTSxJQUFJSSxNQUFNK0QsT0FBTyxzQ0FBeUMsT0FBSEc7UUFDL0Q7UUFDQTdCLFFBQVF1QixHQUFHLENBQUMsNERBQTRETTtJQUMxRTtJQUVBLGlHQUFpRyxHQUNqRyxTQUFTUyxnQkFBZ0JULEVBQWtCO1lBQUVVLFVBQUFBLGlFQUFVO1FBQ3JELE9BQU8sSUFBSTFHLFFBQVEsQ0FBQzJHO1lBQ2xCLElBQUksQ0FBQ1gsSUFBSTtnQkFDUDdCLFFBQVFDLEtBQUssQ0FBQztnQkFDZHVDLFdBQVcsd0JBQXdCO2dCQUNuQztZQUNGO1lBRUE5QztZQUVBLE1BQU16RCxNQUFNLEdBQW1Eb0csT0FBaERyRyxjQUFjWCwrREFBdUJBLEdBQUUsV0FBZ0MsT0FBdkJnSCxtQkFBbUJSO1lBQ2xGN0IsUUFBUXVCLEdBQUcsQ0FBQyxnREFBZ0R0RjtZQUM1RCxNQUFNd0csS0FBSyxJQUFJQyxZQUFZekc7WUFDM0JxRCxNQUFNSyxPQUFPLEdBQUc4QztZQUVoQixNQUFNRSxhQUFhNUcsV0FBVztnQkFDNUIsSUFBSSxDQUFDeUQsVUFBVUcsT0FBTyxFQUFFO29CQUN0QkssUUFBUTRDLElBQUksQ0FBQztvQkFDYko7Z0JBQ0Y7WUFDRixHQUFHRDtZQUVIRSxHQUFHSSxNQUFNLEdBQUc7Z0JBQ1ZyRCxVQUFVRyxPQUFPLEdBQUc7Z0JBQ3BCSyxRQUFRdUIsR0FBRyxDQUFDLDJEQUEyRE07Z0JBQ3ZFaUIsYUFBYUg7Z0JBQ2JIO1lBQ0Y7WUFFQUMsR0FBR00sU0FBUyxHQUFHLENBQUNDO2dCQUNkLElBQUksQ0FBQ0EsSUFBSS9CLElBQUksRUFBRTtnQkFDZixJQUFJO29CQUNGLE1BQU1lLFVBQVVsQixLQUFLQyxLQUFLLENBQUNpQyxJQUFJL0IsSUFBSTtvQkFFbkMsZ0RBQWdEO29CQUNoRCxJQUFJZSxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNpQixJQUFJLE1BQUssU0FBUzt3QkFDN0JqRCxRQUFRQyxLQUFLLENBQUMsbUJBQW1CK0IsUUFBUWtCLFNBQVMsSUFBSWxCLFFBQVFtQixRQUFRLEVBQUVuQixRQUFRL0IsS0FBSzt3QkFDckYsTUFBTW1ELFdBQStCcEIsUUFBUWtCLFNBQVMsSUFBSWxCLFFBQVFtQixRQUFRO3dCQUMxRSxJQUFJQyxVQUFVOzRCQUNaekUsU0FBUyxDQUFDMEUsT0FDUkEsS0FBS2xELEdBQUcsQ0FBQyxDQUFDQyxJQUFPQSxFQUFFa0QsRUFBRSxLQUFLRixXQUFXO3dDQUFFLEdBQUdoRCxDQUFDO3dDQUFFNUMsUUFBUTtvQ0FBUSxJQUFJNEM7d0JBRXJFO3dCQUNBdkIsZ0JBQWdCO3dCQUNoQmE7d0JBQ0EsSUFBSSxDQUFDSCxhQUFhSSxPQUFPLElBQUlrQyxJQUFJMEIsV0FBVzFCO3dCQUM1QztvQkFDRjtvQkFFQSxJQUFJRyxRQUFRaEQsU0FBUyxFQUFFO3dCQUNyQkMsYUFBYTBDLE9BQU9LLFFBQVFoRCxTQUFTO3dCQUNyQ2dCLFFBQVF1QixHQUFHLENBQUMsNkJBQTZCUyxRQUFRaEQsU0FBUztvQkFDNUQ7b0JBRUEsTUFBTXNFLEtBQXlCdEIsUUFBUW1CLFFBQVE7b0JBQy9DLE1BQU1LLEtBQXlCeEIsUUFBUXhFLE1BQU07b0JBRTdDLElBQUk4RixNQUFNRSxJQUFJO3dCQUNaN0UsU0FBUyxDQUFDMEUsT0FDUkEsS0FBS2xELEdBQUcsQ0FBQyxDQUFDQztnQ0FDUixJQUFJQSxFQUFFa0QsRUFBRSxLQUFLQSxJQUFJLE9BQU9sRDtnQ0FDeEIsTUFBTUQsTUFBa0M7b0NBQ3RDc0QsU0FBUztvQ0FDVEMsV0FBVztvQ0FDWHpELE9BQU87Z0NBQ1Q7b0NBQ3VCRTtnQ0FBdkIsT0FBTztvQ0FBRSxHQUFHQyxDQUFDO29DQUFFNUMsUUFBUTJDLENBQUFBLFVBQUFBLEdBQUcsQ0FBQ3FELEdBQUcsY0FBUHJELHFCQUFBQSxVQUFXQyxFQUFFNUMsTUFBTTtnQ0FBQzs0QkFDN0M7d0JBR0YsSUFBSThGLE9BQU8sb0JBQW9CRSxPQUFPLGFBQWE7NEJBQ2pEeEQsUUFBUXVCLEdBQUcsQ0FBQzt3QkFDZDtvQkFDRjtvQkFFQSxJQUFJK0IsT0FBTyx5QkFBeUJFLE9BQU8sYUFBYTt3QkFDdER6RSxjQUFjO3dCQUNkRixnQkFBZ0I7d0JBQ2hCbUIsUUFBUXVCLEdBQUcsQ0FBQzt3QkFDWjdCO29CQUNGO29CQUNBLElBQUk4RCxPQUFPLFNBQVM7d0JBQ2xCM0UsZ0JBQWdCO3dCQUNoQm1CLFFBQVF1QixHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0YsRUFBRSxVQUFNO2dCQUNOLGtDQUFrQztnQkFDcEM7WUFDRjtZQUVBa0IsR0FBR2tCLE9BQU8sR0FBRyxDQUFDMUQ7Z0JBQ1pELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNBO2dCQUMvQyxJQUFJLENBQUNWLGFBQWFJLE9BQU8sSUFBSWtDLElBQUk7b0JBQy9CMEIsV0FBVzFCO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsZUFBZTBCLFdBQVcxQixFQUFVO1FBQ2xDLElBQUl0QyxhQUFhSSxPQUFPLElBQUliLFlBQVk7UUFDeEMsSUFBSTtZQUNGLE1BQU0zQixNQUFNLE1BQU1DLE1BQ2hCLEdBQW1EaUYsT0FBaERyRyxjQUFjUiwrREFBdUJBLEdBQUUsV0FBZ0MsT0FBdkI2RyxtQkFBbUJSLE1BQ3RFO2dCQUFFdkUsT0FBTztZQUFXO1lBRXRCLElBQUlILElBQUlJLEVBQUUsRUFBRTtnQkFDVixNQUFNMEQsT0FBUSxNQUFNOUQsSUFBSXlHLElBQUk7Z0JBSzVCLElBQUkzQyxLQUFLakMsU0FBUyxFQUFFQyxhQUFhZ0MsS0FBS2pDLFNBQVM7Z0JBRS9DLElBQUlpQyxLQUFLdkMsS0FBSyxFQUFFO29CQUNkQyxTQUFTLENBQUMwRSxPQUNSQSxLQUFLbEQsR0FBRyxDQUFDLENBQUNDOzRCQUNSLE1BQU1vRCxLQUFLdkMsS0FBS3ZDLEtBQUssQ0FBRTBCLEVBQUVrRCxFQUFFLENBQUM7NEJBQzVCLE1BQU1uRCxNQUFrQztnQ0FDdEMwRCxTQUFTO2dDQUNUQyxhQUFhO2dDQUNiSixXQUFXO2dDQUNYekQsT0FBTzs0QkFDVDtnQ0FDNEJFOzRCQUE1QixPQUFPcUQsS0FBSztnQ0FBRSxHQUFHcEQsQ0FBQztnQ0FBRTVDLFFBQVEyQyxDQUFBQSxVQUFBQSxHQUFHLENBQUNxRCxHQUFHLGNBQVByRCxxQkFBQUEsVUFBV0MsRUFBRTVDLE1BQU07NEJBQUMsSUFBSTRDO3dCQUN0RDtvQkFHRixNQUFNMkQsT0FBTzlDLEtBQUt2QyxLQUFLLENBQUMsc0JBQXNCLEtBQUs7b0JBQ25ELElBQUlxRixNQUFNO3dCQUNSaEYsY0FBYzt3QkFDZEYsZ0JBQWdCO3dCQUNoQm1CLFFBQVF1QixHQUFHLENBQUM7d0JBQ1o7b0JBQ0Y7b0JBRUEsSUFBSU4sS0FBS3ZDLEtBQUssQ0FBQyxpQkFBaUIsS0FBSyxhQUFhO3dCQUNoRHNCLFFBQVF1QixHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBT3lDLFdBQVc7WUFDbEJoRSxRQUFRQyxLQUFLLENBQUMsbUNBQW1DK0Q7UUFDbkQ7UUFDQWpJLFdBQVcsSUFBTXdILFdBQVcxQixLQUFLO0lBQ25DO0lBRUEsZUFBZW9DLGFBQWEzRCxJQUFVO1FBQ3BDSjtRQUNBLElBQUk7WUFDRiwwRUFBMEU7WUFDMUVGLFFBQVF1QixHQUFHLENBQUM7WUFDWixNQUFNbEIsVUFBVUM7WUFDaEJOLFFBQVF1QixHQUFHLENBQUM7WUFFWiw4QkFBOEI7WUFDOUIsTUFBTTJDLGVBQWUsTUFBTTVDO1lBQzNCdEIsUUFBUXVCLEdBQUcsQ0FBQztZQUNaLE1BQU1lLGdCQUFnQjRCO1lBRXRCLHdCQUF3QjtZQUN4QixNQUFNdEMsMEJBQTBCc0MsY0FBYyxPQUFPO2dCQUNuRGpDLGVBQWU7Z0JBQ2ZDLGdCQUFnQjtnQkFDaEJFLGFBQWE7Z0JBQ2JELGVBQWU7WUFDakI7WUFFQSw2Q0FBNkM7WUFDN0NvQixXQUFXVztRQUNiLEVBQUUsT0FBT2pFLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLDZDQUE2Q0E7WUFDM0RwQixnQkFBZ0I7WUFDaEJhO1FBQ0Y7SUFDRjtJQUVBLGVBQWV5RTtRQUNiakU7UUFDQSxJQUFJO1lBQ0YsTUFBTWdFLGVBQWUsTUFBTTVDO1lBQzNCdEIsUUFBUXVCLEdBQUcsQ0FBQztZQUNaLE1BQU1lLGdCQUFnQjRCO1lBRXRCLE1BQU10QywwQkFBMEJzQyxjQUFjLFVBQVU7Z0JBQ3REakMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkUsYUFBYTtnQkFDYkQsZUFBZTtZQUNqQjtZQUVBb0IsV0FBV1c7UUFDYixFQUFFLE9BQU9qRSxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyxnREFBZ0RBO1lBQzlEcEIsZ0JBQWdCO1lBQ2hCYTtRQUNGO0lBQ0Y7SUFFQSxlQUFlMEU7UUFDYnBFLFFBQVF1QixHQUFHLENBQUMseUNBQXlDckM7UUFDckRLLGFBQWFJLE9BQU8sR0FBRztRQUN2QkQ7UUFDQWIsZ0JBQWdCO1FBQ2hCRixTQUFTdkQscURBQWFBLENBQUMrRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTztnQkFBRSxHQUFHQSxDQUFDO2dCQUFFNUMsUUFBUTtZQUFVO1FBRTdELElBQUkwQixPQUFPO1lBQ1QsSUFBSTtnQkFDRixNQUFNakQsTUFBTUQsY0FBYztnQkFDMUIsTUFBTW1CLE1BQU0sTUFBTUMsTUFBTW5CLEtBQUs7b0JBQzNCb0IsUUFBUTtvQkFDUm1FLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNwRCxNQUFNMEMsS0FBS1csU0FBUyxDQUFDO3dCQUFFdkM7b0JBQU07Z0JBQy9CO2dCQUNBLElBQUksQ0FBQy9CLElBQUlJLEVBQUUsRUFBRTtvQkFDWCxNQUFNbUUsTUFBTSxNQUFNdkUsSUFBSXVELElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07b0JBQ3pDLE1BQU0sSUFBSWhELE1BQU0rRCxPQUFPO2dCQUN6QjtnQkFDQTFCLFFBQVF1QixHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU84QyxhQUFhO2dCQUNwQnJFLFFBQVFDLEtBQUssQ0FBQywyQ0FBMkNvRTtZQUMzRDtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0wzRjtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBNkU7UUFDQUU7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc3RhbC9Eb2N1bWVudHMvUHJvamVjdHMvY3VycmljYWxpZ24vZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvcmVwb3J0L3VzZU9yY2hlc3RyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29tcG9uZW50cy9yZXBvcnQvdXNlT3JjaGVzdHJhdG9yLnRzXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIElOSVRJQUxfU1RFUFMsXG4gIE9SQ0hFU1RSQVRPUl9FVkVOVFNfVVJMLFxuICBPUkNIRVNUUkFUT1JfSU5JVF9VUkwsXG4gIE9SQ0hFU1RSQVRPUl9TVEFSVF9QSVBFTElORV9VUkwsXG4gIE9SQ0hFU1RSQVRPUl9TVEFUVVNfVVJMLFxuICBQREZfVVBMT0FEX1VSTCxcbiAgQVBJX0JBU0UsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgT3JjaGVzdHJhdG9yU291cmNlLCBQcm9jZXNzU3RlcCwgU3RlcFN0YXR1cyB9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIFJ1bkZsYWdzID0ge1xuICBzY3JhcGVFbmFibGVkPzogYm9vbGVhbjtcbiAgZXh0cmFjdEVuYWJsZWQ/OiBib29sZWFuO1xuICByZXRyYWluTW9kZWxzPzogYm9vbGVhbjtcbiAgZ2VuZXJhdGVQZGY/OiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgbXMpKTtcbn1cblxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsKS50b1N0cmluZygpO1xuICB9IGNhdGNoIHtcbiAgICBjb25zdCBiYXNlID0gQVBJX0JBU0U/LnJlcGxhY2UoL1xcLyskLywgJycpID8/ICcnO1xuICAgIGNvbnN0IHBhdGggPSB1cmwuc3RhcnRzV2l0aCgnLycpID8gdXJsIDogYC8ke3VybH1gO1xuICAgIHJldHVybiBgJHtiYXNlfSR7cGF0aH1gO1xuICB9XG59XG5cbi8qKiBQcm9iZSBVUkwgdW50aWwgaXQgcmVzcG9uZHMgT0suIFRyaWVzIEhFQUQsIGZhbGxzIGJhY2sgdG8gR0VUIGlmIG5lZWRlZC4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFJlYWNoYWJsZSh1cmw6IHN0cmluZywgdHJpZXMgPSAxMCwgZGVsYXlNcyA9IDUwMCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBhYnMgPSB0b0Fic29sdXRlVXJsKHVybCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZXM7IGkrKykge1xuICAgIGNvbnN0IGJ1c3QgPSBgX3Q9JHtEYXRlLm5vdygpfS0ke2l9YDtcbiAgICBjb25zdCBzZXAgPSBhYnMuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgICBjb25zdCBwcm9iZVVybCA9IGAke2Fic30ke3NlcH0ke2J1c3R9YDtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHByb2JlVXJsLCB7IG1ldGhvZDogJ0hFQUQnLCBjYWNoZTogJ25vLXN0b3JlJyB9KTtcbiAgICAgIGlmIChyZXMub2spIHJldHVybiB0cnVlO1xuXG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA1IHx8IHJlcy5zdGF0dXMgPT09IDUwMSkge1xuICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChwcm9iZVVybCwgeyBtZXRob2Q6ICdHRVQnLCBjYWNoZTogJ25vLXN0b3JlJyB9KTtcbiAgICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBpZ25vcmUgYW5kIHJldHJ5XG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKGRlbGF5TXMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqIERvd25sb2FkIGEgVVJMIGFzIGEgZmlsZSB3aXRob3V0IHBhZ2UgbmF2aWdhdGlvbi4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVXJsQXNGaWxlKHVybDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGFicyA9IHRvQWJzb2x1dGVVcmwodXJsKTtcbiAgY29uc3QgYnVzdCA9IGFicy5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHthYnN9JHtidXN0fV9kbD0ke0RhdGUubm93KCl9YCwgeyBjYWNoZTogJ25vLXN0b3JlJyB9KTtcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgRG93bmxvYWQgZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXMuYmxvYigpO1xuICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhLmhyZWYgPSBvYmplY3RVcmw7XG4gIGEuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgYS5jbGljaygpO1xuICBhLnJlbW92ZSgpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VPcmNoZXN0cmF0b3IoKSB7XG4gIGNvbnN0IFtzdGVwcywgc2V0U3RlcHNdID0gdXNlU3RhdGU8UHJvY2Vzc1N0ZXBbXT4oSU5JVElBTF9TVEVQUyk7XG4gIGNvbnN0IFtpc1Byb2Nlc3NpbmcsIHNldElzUHJvY2Vzc2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NvbXBsZXRlLCBzZXRJc0NvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3JlcG9ydFVybCwgc2V0UmVwb3J0VXJsXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbam9iSWQsIHNldEpvYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIE9QVElPTkFMOiBwcmV2aWV3IHdoYXQgc2Nhbi1wZGYgcGFyc2VkXG4gIGNvbnN0IFtwYXJzZWRSb3dzLCBzZXRQYXJzZWRSb3dzXSA9IHVzZVN0YXRlPGFueVtdIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXNSZWYgPSB1c2VSZWY8RXZlbnRTb3VyY2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuY2VsbGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgb3BlbmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZG93bmxvYWRTdGFydGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBjbG9zZVN0cmVhbSA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZXNSZWYuY3VycmVudD8uY2xvc2UoKTtcbiAgICB9IGNhdGNoIHt9XG4gICAgZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgb3BlbmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBjbG9zZVN0cmVhbSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuXG4gIC8vIEF1dG8tZG93bmxvYWQgd2hlbiByZXBvcnRVcmwgYXJyaXZlcyDigJQgV0lUSE9VVCBuYXZpZ2F0aW5nXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghcmVwb3J0VXJsIHx8IGRvd25sb2FkU3RhcnRlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBkb3dubG9hZFN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWFjaGFibGUgPSBhd2FpdCB3YWl0VW50aWxSZWFjaGFibGUocmVwb3J0VXJsLCAxNCwgNTAwKTtcbiAgICAgICAgaWYgKCFyZWFjaGFibGUpIHRocm93IG5ldyBFcnJvcignUmVwb3J0IFVSTCBpcyBub3QgcmVhY2hhYmxlIHlldCcpO1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWQgPSBgYWxpZ25tZW50X3JlcG9ydF8ke2pvYklkID8/IERhdGUubm93KCl9LnBkZmA7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkVXJsQXNGaWxlKHJlcG9ydFVybCwgc3VnZ2VzdGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogQXV0by1kb3dubG9hZCBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgZG93bmxvYWRTdGFydGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3JlcG9ydFVybCwgam9iSWRdKTtcblxuICBjb25zdCByZXNldFVJID0gKCkgPT4ge1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcbiAgICBzZXRJc0NvbXBsZXRlKGZhbHNlKTtcbiAgICBzZXRSZXBvcnRVcmwobnVsbCk7XG4gICAgc2V0UGFyc2VkUm93cyhudWxsKTtcbiAgICBzZXRTdGVwcyhJTklUSUFMX1NURVBTLm1hcCgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGVuZGluZycgfSkpKTtcbiAgICBjYW5jZWxsZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGRvd25sb2FkU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgUERGIHRvIHRoZSBiYWNrZW5kIHNjYW4gZW5kcG9pbnQuXG4gICAqIElNUE9SVEFOVDogYmFja2VuZCBleHBlY3RzIGZpZWxkIG5hbWUgJ3BkZicgPT4gYXN5bmMgZGVmIHNjYW5fcGRmX2VuZHBvaW50KHBkZjogVXBsb2FkRmlsZSA9IEZpbGUoLi4uKSlcbiAgICogUmV0dXJucyB0aGUgSlNPTiBib2R5IHNvIGNhbGxlcnMgY2FuIHJlYWQgcGFyc2VkX3Jvd3MgaWYgZGVzaXJlZC5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBkZihmaWxlOiBGaWxlKTogUHJvbWlzZTx7IGluc2VydGVkOiBhbnlbXTsgcGFyc2VkX3Jvd3M6IGFueVtdOyByYXdfdGV4dF9sZW46IG51bWJlciB9PiB7XG4gICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm0uYXBwZW5kKCdwZGYnLCBmaWxlKTsgLy8gPC0tIEZJWDogbXVzdCBiZSAncGRmJywgbm90ICdmaWxlJ1xuICAgIGNvbnN0IHVybCA9IHRvQWJzb2x1dGVVcmwoUERGX1VQTE9BRF9VUkwpOyAvLyBlbnN1cmUgYWJzb2x1dGUgVVJMXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IGZvcm0gfSk7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAvLyBUeXBpY2FsIEZhc3RBUEkgZXJyb3IgYm9keSBzaGFwZToge1wiZGV0YWlsXCI6IFwiLi4uXCJ9XG4gICAgICBsZXQgZGV0YWlsID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgZGV0YWlsID0gaj8uZGV0YWlsIHx8ICcnO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgY29uc3QgZXhwbGFpbiA9IGRldGFpbCB8fCB0ZXh0IHx8IGBVcGxvYWQgZmFpbGVkICgke3Jlcy5zdGF0dXN9KWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjYW4tcGRmIGVycm9yOiAke2V4cGxhaW59YCk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugc3VjY2VzcyBib2R5XG4gICAgbGV0IGRhdGE6IGFueSA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0IHx8ICd7fScpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FuLXBkZiByZXR1cm5lZCBub24tSlNPTiByZXNwb25zZScpO1xuICAgIH1cbiAgICBjb25zdCByb3dzID0gQXJyYXkuaXNBcnJheShkYXRhPy5wYXJzZWRfcm93cykgPyBkYXRhLnBhcnNlZF9yb3dzIDogW107XG4gICAgc2V0UGFyc2VkUm93cyhyb3dzKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGluaXRPcmNoZXN0cmF0b3JKb2IoKSB7XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBSZXF1ZXN0aW5nIG5ldyBqb2JJZCBmcm9tIGJhY2tlbmQuLi4nKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh0b0Fic29sdXRlVXJsKE9SQ0hFU1RSQVRPUl9JTklUX1VSTCksIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgfSk7XG4gICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eHQgfHwgJ0ZhaWxlZCB0byBpbml0aWFsaXplIG9yY2hlc3RyYXRvciBqb2InKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9ICh0eHQgPyBKU09OLnBhcnNlKHR4dCkgOiB7fSkgYXMgYW55O1xuICAgIGlmIChkYXRhPy5qb2JJZCkge1xuICAgICAgc2V0Sm9iSWQoU3RyaW5nKGRhdGEuam9iSWQpKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUmVjZWl2ZWQgam9iSWQ6JywgZGF0YS5qb2JJZCk7XG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGEuam9iSWQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGpvYklkIHJlY2VpdmVkIGZyb20gaW5pdCBlbmRwb2ludCcpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRPcmNoZXN0cmF0b3JQaXBlbGluZShcbiAgICBpZDogc3RyaW5nLFxuICAgIHNvdXJjZTogT3JjaGVzdHJhdG9yU291cmNlLFxuICAgIGZsYWdzOiBSdW5GbGFncyA9IHt9XG4gICkge1xuICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUmVxdWVzdGluZyBiYWNrZW5kIHRvIFNUQVJUIHBpcGVsaW5lIGZvciBqb2JJZDonLCBpZCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNjcmFwZUVuYWJsZWQ6IGZsYWdzLnNjcmFwZUVuYWJsZWQgPz8gdHJ1ZSxcbiAgICAgIGV4dHJhY3RFbmFibGVkOiBmbGFncy5leHRyYWN0RW5hYmxlZCA/PyB0cnVlLFxuICAgICAgcmV0cmFpbk1vZGVsczogZmxhZ3MucmV0cmFpbk1vZGVscyA/PyBmYWxzZSxcbiAgICAgIGdlbmVyYXRlUGRmOiBmbGFncy5nZW5lcmF0ZVBkZiA/PyB0cnVlLFxuICAgIH07XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgIHRvQWJzb2x1dGVVcmwoYCR7T1JDSEVTVFJBVE9SX1NUQVJUX1BJUEVMSU5FX1VSTH0vJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWApLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eHQgfHwgYEZhaWxlZCB0byBzdGFydCBwaXBlbGluZSBmb3Igam9iSWQgJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBCYWNrZW5kIGFja25vd2xlZGdlZCBwaXBlbGluZSBzdGFydCBmb3Igam9iSWQ6JywgaWQpO1xuICB9XG5cbiAgLyoqIE9wZW5zIFNTRS4gUmVzb2x2ZXMgb25jZSBvcGVuZWQgT1IgYWZ0ZXIgYSBzaG9ydCBncmFjZSBwZXJpb2Qgc28gd2UgY2FuIGZhbGxiYWNrIHRvIHBvbGxpbmcuICovXG4gIGZ1bmN0aW9uIG9wZW5FdmVudFN0cmVhbShpZD86IHN0cmluZyB8IG51bGwsIGdyYWNlTXMgPSAxMjAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBDYW5ub3Qgb3BlbiBFdmVudFNvdXJjZSwgam9iSWQgaXMgbnVsbC4nKTtcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyBsZXQgcG9sbGluZyBoYW5kbGUgaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbG9zZVN0cmVhbSgpO1xuXG4gICAgICBjb25zdCB1cmwgPSBgJHt0b0Fic29sdXRlVXJsKE9SQ0hFU1RSQVRPUl9FVkVOVFNfVVJMKX0/am9iSWQ9JHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWA7XG4gICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IEF0dGVtcHRpbmcgdG8gb3BlbiBFdmVudFNvdXJjZSB0bzonLCB1cmwpO1xuICAgICAgY29uc3QgZXMgPSBuZXcgRXZlbnRTb3VyY2UodXJsKTtcbiAgICAgIGVzUmVmLmN1cnJlbnQgPSBlcztcblxuICAgICAgY29uc3QgZ3JhY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIW9wZW5lZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGUk9OVEVORDogU1NFIGRpZCBub3Qgb3BlbiB3aXRoaW4gZ3JhY2UgcGVyaW9kOyBjb250aW51aW5nIHdpdGggcG9sbGluZyBmYWxsYmFjay4nKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGdyYWNlTXMpO1xuXG4gICAgICBlcy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIG9wZW5lZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBTU0UgY29ubmVjdGlvbiBvcGVuZWQgc3VjY2Vzc2Z1bGx5IGZvciBqb2JJZDonLCBpZCk7XG4gICAgICAgIGNsZWFyVGltZW91dChncmFjZVRpbWVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgZXMub25tZXNzYWdlID0gKGV2dCkgPT4ge1xuICAgICAgICBpZiAoIWV2dC5kYXRhKSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuXG4gICAgICAgICAgLy8gLS0tIEhhbmRsZSBleHBsaWNpdCBwaXBlbGluZSBlcnJvciBldmVudHMgLS0tXG4gICAgICAgICAgaWYgKHBheWxvYWQ/LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BJUEVMSU5FIEVSUk9SOicsIHBheWxvYWQuZmFpbGVkX2F0IHx8IHBheWxvYWQuZnVuY3Rpb24sIHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkRm46IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBheWxvYWQuZmFpbGVkX2F0IHx8IHBheWxvYWQuZnVuY3Rpb247XG4gICAgICAgICAgICBpZiAoZmFpbGVkRm4pIHtcbiAgICAgICAgICAgICAgc2V0U3RlcHMoKHByZXYpID0+XG4gICAgICAgICAgICAgICAgcHJldi5tYXAoKHMpID0+IChzLmZuID09PSBmYWlsZWRGbiA/IHsgLi4ucywgc3RhdHVzOiAnZXJyb3InIH0gOiBzKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICBjbG9zZVN0cmVhbSgpO1xuICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWRSZWYuY3VycmVudCAmJiBpZCkgcG9sbFN0YXR1cyhpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBheWxvYWQucmVwb3J0VXJsKSB7XG4gICAgICAgICAgICBzZXRSZXBvcnRVcmwoU3RyaW5nKHBheWxvYWQucmVwb3J0VXJsKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFJlcG9ydCBVUkwgc2V0OicsIHBheWxvYWQucmVwb3J0VXJsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGF5bG9hZC5mdW5jdGlvbjtcbiAgICAgICAgICBjb25zdCBzdDogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGF5bG9hZC5zdGF0dXM7XG5cbiAgICAgICAgICBpZiAoZm4gJiYgc3QpIHtcbiAgICAgICAgICAgIHNldFN0ZXBzKChwcmV2KSA9PlxuICAgICAgICAgICAgICBwcmV2Lm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzLmZuICE9PSBmbikgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBTdGVwU3RhdHVzPiA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQ6ICdpbi1wcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5zLCBzdGF0dXM6IG1hcFtzdF0gPz8gcy5zdGF0dXMgfTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChmbiA9PT0gJ2ZpbmFsX2NoZWNraW5nJyAmJiBzdCA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBGaW5hbCBWYWxpZGF0aW9uIHN0ZXAgY29tcGxldGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbiA9PT0gJ2dlbmVyYXRlX3BkZl9yZXBvcnQnICYmIHN0ID09PSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgc2V0SXNDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFByb2Nlc3MgY29tcGxldGUsIGNsb3NpbmcgU1NFLicpO1xuICAgICAgICAgICAgY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBQcm9jZXNzIGVycm9yIGRldGVjdGVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZXMgb3Igbm9uLUpTT047IGlnbm9yZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlcy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBTU0UgRXJyb3Igb2NjdXJyZWQ6JywgZXJyb3IpO1xuICAgICAgICBpZiAoIWNhbmNlbGxlZFJlZi5jdXJyZW50ICYmIGlkKSB7XG4gICAgICAgICAgcG9sbFN0YXR1cyhpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBwb2xsU3RhdHVzKGlkOiBzdHJpbmcpIHtcbiAgICBpZiAoY2FuY2VsbGVkUmVmLmN1cnJlbnQgfHwgaXNDb21wbGV0ZSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7dG9BYnNvbHV0ZVVybChPUkNIRVNUUkFUT1JfU1RBVFVTX1VSTCl9P2pvYklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gLFxuICAgICAgICB7IGNhY2hlOiAnbm8tc3RvcmUnIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzLmpzb24oKSkgYXMge1xuICAgICAgICAgIHN0ZXBzPzogUmVjb3JkPCdwZW5kaW5nJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdlcnJvcicgfCBzdHJpbmcsIGFueT47XG4gICAgICAgICAgcmVwb3J0VXJsPzogc3RyaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkYXRhLnJlcG9ydFVybCkgc2V0UmVwb3J0VXJsKGRhdGEucmVwb3J0VXJsKTtcblxuICAgICAgICBpZiAoZGF0YS5zdGVwcykge1xuICAgICAgICAgIHNldFN0ZXBzKChwcmV2KSA9PlxuICAgICAgICAgICAgcHJldi5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc3QgPSBkYXRhLnN0ZXBzIVtzLmZuXTtcbiAgICAgICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBTdGVwU3RhdHVzPiA9IHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nOiAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgaW5fcHJvZ3Jlc3M6ICdpbi1wcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ID8geyAuLi5zLCBzdGF0dXM6IG1hcFtzdF0gPz8gcy5zdGF0dXMgfSA6IHM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBkb25lID0gZGF0YS5zdGVwc1snZ2VuZXJhdGVfcGRmX3JlcG9ydCddID09PSAnY29tcGxldGVkJztcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2V0SXNDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFBvbGxpbmcgZGV0ZWN0ZWQgcHJvY2VzcyBjb21wbGV0ZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF0YS5zdGVwc1snZmluYWxfY2hlY2tpbmcnXSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogRmluYWwgVmFsaWRhdGlvbiBzdGVwIGNvbXBsZXRlZCAodmlhIHBvbGxpbmcpLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHBvbGxFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRlJPTlRFTkQ6IEVycm9yIGR1cmluZyBwb2xsaW5nOicsIHBvbGxFcnJvcik7XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4gcG9sbFN0YXR1cyhpZCksIDEwMDApO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRGcm9tUGRmKGZpbGU6IEZpbGUpIHtcbiAgICByZXNldFVJKCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIDEpIFVwbG9hZCAmIHBhcnNlIFBERiBmaXJzdCBzbyBjb3Vyc2VzIGFyZSBpbiBEQiBiZWZvcmUgcGlwZWxpbmUgYmVnaW5zXG4gICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFN0YXJ0aW5nIFBERiB1cGxvYWQgdG8gc2NhbiBlbmRwb2ludC4uLicpO1xuICAgICAgYXdhaXQgdXBsb2FkUGRmKGZpbGUpO1xuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBQREYgdXBsb2FkIGNvbXBsZXRlLicpO1xuXG4gICAgICAvLyAyKSBJbml0IGpvYiBhbmQgb3BlbiBzdHJlYW1cbiAgICAgIGNvbnN0IGN1cnJlbnRKb2JJZCA9IGF3YWl0IGluaXRPcmNoZXN0cmF0b3JKb2IoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogT3BlbmluZyBTU0UgKHdpdGggcG9sbGluZyBmYWxsYmFjaykuLi4nKTtcbiAgICAgIGF3YWl0IG9wZW5FdmVudFN0cmVhbShjdXJyZW50Sm9iSWQpO1xuXG4gICAgICAvLyAzKSBTdGFydCB0aGUgcGlwZWxpbmVcbiAgICAgIGF3YWl0IHN0YXJ0T3JjaGVzdHJhdG9yUGlwZWxpbmUoY3VycmVudEpvYklkLCAncGRmJywge1xuICAgICAgICBzY3JhcGVFbmFibGVkOiB0cnVlLFxuICAgICAgICBleHRyYWN0RW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZ2VuZXJhdGVQZGY6IHRydWUsXG4gICAgICAgIHJldHJhaW5Nb2RlbHM6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIDQpIFBvbGwgc3RhdHVzIGFzIGEgZmFsbGJhY2sgYWxvbmdzaWRlIFNTRVxuICAgICAgcG9sbFN0YXR1cyhjdXJyZW50Sm9iSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogRXJyb3IgaW4gc3RhcnRGcm9tUGRmIHdvcmtmbG93OicsIGVycm9yKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICBjbG9zZVN0cmVhbSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RnJvbVN0b3JlZCgpIHtcbiAgICByZXNldFVJKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRKb2JJZCA9IGF3YWl0IGluaXRPcmNoZXN0cmF0b3JKb2IoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogT3BlbmluZyBTU0UgKHdpdGggcG9sbGluZyBmYWxsYmFjaykuLi4nKTtcbiAgICAgIGF3YWl0IG9wZW5FdmVudFN0cmVhbShjdXJyZW50Sm9iSWQpO1xuXG4gICAgICBhd2FpdCBzdGFydE9yY2hlc3RyYXRvclBpcGVsaW5lKGN1cnJlbnRKb2JJZCwgJ3N0b3JlZCcsIHtcbiAgICAgICAgc2NyYXBlRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZXh0cmFjdEVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGdlbmVyYXRlUGRmOiB0cnVlLFxuICAgICAgICByZXRyYWluTW9kZWxzOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBwb2xsU3RhdHVzKGN1cnJlbnRKb2JJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBFcnJvciBpbiBzdGFydEZyb21TdG9yZWQgd29ya2Zsb3c6JywgZXJyb3IpO1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgIGNsb3NlU3RyZWFtKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogQ2FuY2VsIHJlcXVlc3RlZCBmb3Igam9iSWQ6Jywgam9iSWQpO1xuICAgIGNhbmNlbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjbG9zZVN0cmVhbSgpO1xuICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgc2V0U3RlcHMoSU5JVElBTF9TVEVQUy5tYXAoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ3BlbmRpbmcnIH0pKSk7XG5cbiAgICBpZiAoam9iSWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRvQWJzb2x1dGVVcmwoJy9hcGkvb3JjaGVzdHJhdG9yL2NhbmNlbCcpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGpvYklkIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICBjb25zdCB0eHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+ICcnKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHh0IHx8ICdDYW5jZWwgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IENhbmNlbCByZXF1ZXN0IHNlbnQgdG8gYmFja2VuZC4nKTtcbiAgICAgIH0gY2F0Y2ggKGNhbmNlbEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBFcnJvciBzZW5kaW5nIGNhbmNlbCByZXF1ZXN0OicsIGNhbmNlbEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0ZXBzLFxuICAgIGlzUHJvY2Vzc2luZyxcbiAgICBpc0NvbXBsZXRlLFxuICAgIHJlcG9ydFVybCxcbiAgICBqb2JJZCxcbiAgICBwYXJzZWRSb3dzLCAgICAgICAgIC8vIG9wdGlvbmFsIHByZXZpZXcgZGF0YSBmcm9tIHNjYW4tcGRmXG4gICAgc3RhcnRGcm9tUGRmLFxuICAgIHN0YXJ0RnJvbVN0b3JlZCxcbiAgICBjYW5jZWwsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJJTklUSUFMX1NURVBTIiwiT1JDSEVTVFJBVE9SX0VWRU5UU19VUkwiLCJPUkNIRVNUUkFUT1JfSU5JVF9VUkwiLCJPUkNIRVNUUkFUT1JfU1RBUlRfUElQRUxJTkVfVVJMIiwiT1JDSEVTVFJBVE9SX1NUQVRVU19VUkwiLCJQREZfVVBMT0FEX1VSTCIsIkFQSV9CQVNFIiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInRvQWJzb2x1dGVVcmwiLCJ1cmwiLCJVUkwiLCJ0b1N0cmluZyIsImJhc2UiLCJyZXBsYWNlIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJ3YWl0VW50aWxSZWFjaGFibGUiLCJ0cmllcyIsImRlbGF5TXMiLCJhYnMiLCJpIiwiYnVzdCIsIkRhdGUiLCJub3ciLCJzZXAiLCJpbmNsdWRlcyIsInByb2JlVXJsIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsIm9rIiwic3RhdHVzIiwiZG93bmxvYWRVcmxBc0ZpbGUiLCJmaWxlbmFtZSIsIkVycm9yIiwiYmxvYiIsIm9iamVjdFVybCIsImNyZWF0ZU9iamVjdFVSTCIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZSIsInJldm9rZU9iamVjdFVSTCIsInVzZU9yY2hlc3RyYXRvciIsInN0ZXBzIiwic2V0U3RlcHMiLCJpc1Byb2Nlc3NpbmciLCJzZXRJc1Byb2Nlc3NpbmciLCJpc0NvbXBsZXRlIiwic2V0SXNDb21wbGV0ZSIsInJlcG9ydFVybCIsInNldFJlcG9ydFVybCIsImpvYklkIiwic2V0Sm9iSWQiLCJwYXJzZWRSb3dzIiwic2V0UGFyc2VkUm93cyIsImVzUmVmIiwiY2FuY2VsbGVkUmVmIiwib3BlbmVkUmVmIiwiZG93bmxvYWRTdGFydGVkUmVmIiwiY2xvc2VTdHJlYW0iLCJjdXJyZW50IiwiY2xvc2UiLCJyZWFjaGFibGUiLCJzdWdnZXN0ZWQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJyZXNldFVJIiwibWFwIiwicyIsInVwbG9hZFBkZiIsImZpbGUiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ0ZXh0IiwiY2F0Y2giLCJkZXRhaWwiLCJqIiwiSlNPTiIsInBhcnNlIiwiZXhwbGFpbiIsImRhdGEiLCJyb3dzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VkX3Jvd3MiLCJpbml0T3JjaGVzdHJhdG9ySm9iIiwibG9nIiwiaGVhZGVycyIsInN0cmluZ2lmeSIsInR4dCIsIlN0cmluZyIsInN0YXJ0T3JjaGVzdHJhdG9yUGlwZWxpbmUiLCJpZCIsInNvdXJjZSIsImZsYWdzIiwicGF5bG9hZCIsInNjcmFwZUVuYWJsZWQiLCJleHRyYWN0RW5hYmxlZCIsInJldHJhaW5Nb2RlbHMiLCJnZW5lcmF0ZVBkZiIsImVuY29kZVVSSUNvbXBvbmVudCIsIm9wZW5FdmVudFN0cmVhbSIsImdyYWNlTXMiLCJyZXNvbHZlIiwiZXMiLCJFdmVudFNvdXJjZSIsImdyYWNlVGltZXIiLCJ3YXJuIiwib25vcGVuIiwiY2xlYXJUaW1lb3V0Iiwib25tZXNzYWdlIiwiZXZ0IiwidHlwZSIsImZhaWxlZF9hdCIsImZ1bmN0aW9uIiwiZmFpbGVkRm4iLCJwcmV2IiwiZm4iLCJwb2xsU3RhdHVzIiwic3QiLCJzdGFydGVkIiwiY29tcGxldGVkIiwib25lcnJvciIsImpzb24iLCJwZW5kaW5nIiwiaW5fcHJvZ3Jlc3MiLCJkb25lIiwicG9sbEVycm9yIiwic3RhcnRGcm9tUGRmIiwiY3VycmVudEpvYklkIiwic3RhcnRGcm9tU3RvcmVkIiwiY2FuY2VsIiwiY2FuY2VsRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/report/useOrchestrator.ts\n"));

/***/ })

});