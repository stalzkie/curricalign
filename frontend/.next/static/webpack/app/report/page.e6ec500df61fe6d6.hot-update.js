"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/report/page",{

/***/ "(app-pages-browser)/./src/components/report/useOrchestrator.ts":
/*!**************************************************!*\
  !*** ./src/components/report/useOrchestrator.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOrchestrator: () => (/* binding */ useOrchestrator)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./src/components/report/constants.ts\");\n// useOrchestrator.ts\n/* __next_internal_client_entry_do_not_use__ useOrchestrator auto */ \n\nfunction sleep(ms) {\n    return new Promise((r)=>setTimeout(r, ms));\n}\nfunction toAbsoluteUrl(url) {\n    try {\n        return new URL(url).toString();\n    } catch (e) {\n        var _API_BASE_replace;\n        const base = (_API_BASE_replace = _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === null || _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE === void 0 ? void 0 : _constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE.replace(/\\/+$/, '')) !== null && _API_BASE_replace !== void 0 ? _API_BASE_replace : '';\n        const path = url.startsWith('/') ? url : \"/\".concat(url);\n        return \"\".concat(base).concat(path);\n    }\n}\n/** Probe URL until it responds OK. Tries HEAD, falls back to GET if needed. */ async function waitUntilReachable(url) {\n    let tries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, delayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500;\n    const abs = toAbsoluteUrl(url);\n    for(let i = 0; i < tries; i++){\n        const bust = \"_t=\".concat(Date.now(), \"-\").concat(i);\n        const sep = abs.includes('?') ? '&' : '?';\n        const probeUrl = \"\".concat(abs).concat(sep).concat(bust);\n        try {\n            let res = await fetch(probeUrl, {\n                method: 'HEAD',\n                cache: 'no-store'\n            });\n            if (res.ok) return true;\n            if (res.status === 405 || res.status === 501) {\n                res = await fetch(probeUrl, {\n                    method: 'GET',\n                    cache: 'no-store'\n                });\n                if (res.ok) return true;\n            }\n        } catch (e) {\n        // ignore and retry\n        }\n        await sleep(delayMs);\n    }\n    return false;\n}\n/** Download a URL as a file without page navigation. */ async function downloadUrlAsFile(url, filename) {\n    const abs = toAbsoluteUrl(url);\n    const bust = abs.includes('?') ? '&' : '?';\n    const res = await fetch(\"\".concat(abs).concat(bust, \"_dl=\").concat(Date.now()), {\n        cache: 'no-store'\n    });\n    if (!res.ok) throw new Error(\"Download failed: \".concat(res.status));\n    const blob = await res.blob();\n    const objectUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = objectUrl;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(objectUrl);\n}\nfunction useOrchestrator() {\n    const [steps, setSteps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS);\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [reportUrl, setReportUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [jobId, setJobId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const esRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const cancelledRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const openedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const downloadStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const closeStream = ()=>{\n        try {\n            var _esRef_current;\n            (_esRef_current = esRef.current) === null || _esRef_current === void 0 ? void 0 : _esRef_current.close();\n        } catch (e) {}\n        esRef.current = null;\n        openedRef.current = false;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            return ({\n                \"useOrchestrator.useEffect\": ()=>closeStream()\n            })[\"useOrchestrator.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], []);\n    // Auto-download when reportUrl arrives â€” WITHOUT navigating\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOrchestrator.useEffect\": ()=>{\n            ({\n                \"useOrchestrator.useEffect\": async ()=>{\n                    if (!reportUrl || downloadStartedRef.current) return;\n                    downloadStartedRef.current = true;\n                    try {\n                        const reachable = await waitUntilReachable(reportUrl, 14, 500);\n                        if (!reachable) throw new Error('Report URL is not reachable yet');\n                        const suggested = \"alignment_report_\".concat(jobId !== null && jobId !== void 0 ? jobId : Date.now(), \".pdf\");\n                        await downloadUrlAsFile(reportUrl, suggested);\n                    } catch (err) {\n                        console.error('FRONTEND: Auto-download failed:', err);\n                        downloadStartedRef.current = false;\n                    }\n                }\n            })[\"useOrchestrator.useEffect\"]();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useOrchestrator.useEffect\"], [\n        reportUrl,\n        jobId\n    ]);\n    const resetUI = ()=>{\n        setIsProcessing(true);\n        setIsComplete(false);\n        setReportUrl(null);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        cancelledRef.current = false;\n        downloadStartedRef.current = false;\n    };\n    async function uploadPdf(file) {\n        const form = new FormData();\n        form.append('file', file);\n        const res = await fetch(_constants__WEBPACK_IMPORTED_MODULE_1__.PDF_UPLOAD_URL, {\n            method: 'POST',\n            body: form\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || 'Failed to upload PDF');\n        }\n    }\n    async function initOrchestratorJob() {\n        console.log('FRONTEND: Requesting new jobId from backend...');\n        const res = await fetch(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_INIT_URL, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({})\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || 'Failed to initialize orchestrator job');\n        }\n        const data = await res.json().catch(()=>({}));\n        if (data === null || data === void 0 ? void 0 : data.jobId) {\n            setJobId(String(data.jobId));\n            console.log('FRONTEND: Received jobId:', data.jobId);\n            return data.jobId;\n        }\n        throw new Error('No jobId received from init endpoint');\n    }\n    async function startOrchestratorPipeline(id, source) {\n        let flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        console.log('FRONTEND: Requesting backend to START pipeline for jobId:', id);\n        var _flags_scrapeEnabled, _flags_extractEnabled, _flags_retrainModels, _flags_generatePdf;\n        const payload = {\n            source,\n            scrapeEnabled: (_flags_scrapeEnabled = flags.scrapeEnabled) !== null && _flags_scrapeEnabled !== void 0 ? _flags_scrapeEnabled : true,\n            extractEnabled: (_flags_extractEnabled = flags.extractEnabled) !== null && _flags_extractEnabled !== void 0 ? _flags_extractEnabled : true,\n            retrainModels: (_flags_retrainModels = flags.retrainModels) !== null && _flags_retrainModels !== void 0 ? _flags_retrainModels : false,\n            generatePdf: (_flags_generatePdf = flags.generatePdf) !== null && _flags_generatePdf !== void 0 ? _flags_generatePdf : true\n        };\n        const res = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_START_PIPELINE_URL, \"/\").concat(encodeURIComponent(id)), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(payload)\n        });\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>'');\n            throw new Error(txt || \"Failed to start pipeline for jobId \".concat(id));\n        }\n        console.log('FRONTEND: Backend acknowledged pipeline start for jobId:', id);\n    }\n    /** Opens SSE. Resolves once opened OR after a short grace period so we can fallback to polling. */ function openEventStream(id) {\n        let graceMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1200;\n        return new Promise((resolve)=>{\n            if (!id) {\n                console.error('FRONTEND: Cannot open EventSource, jobId is null.');\n                resolve(); // let polling handle it\n                return;\n            }\n            closeStream();\n            const url = \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_EVENTS_URL, \"?jobId=\").concat(encodeURIComponent(id));\n            console.log('FRONTEND: Attempting to open EventSource to:', url);\n            const es = new EventSource(url);\n            esRef.current = es;\n            const graceTimer = setTimeout(()=>{\n                if (!openedRef.current) {\n                    console.warn('FRONTEND: SSE did not open within grace period; continuing with polling fallback.');\n                    resolve();\n                }\n            }, graceMs);\n            es.onopen = ()=>{\n                openedRef.current = true;\n                console.log('FRONTEND: SSE connection opened successfully for jobId:', id);\n                clearTimeout(graceTimer);\n                resolve();\n            };\n            es.onmessage = (evt)=>{\n                if (!evt.data) return;\n                try {\n                    const payload = JSON.parse(evt.data);\n                    // --- Handle explicit pipeline error events ---\n                    if ((payload === null || payload === void 0 ? void 0 : payload.type) === 'error') {\n                        console.error('PIPELINE ERROR:', payload.failed_at || payload.function, payload.error);\n                        // Mark the failed step as error if provided\n                        const failedFn = payload.failed_at || payload.function;\n                        if (failedFn) {\n                            setSteps((prev)=>prev.map((s)=>s.fn === failedFn ? {\n                                        ...s,\n                                        status: 'error'\n                                    } : s));\n                        }\n                        setIsProcessing(false);\n                        closeStream();\n                        if (!cancelledRef.current && id) pollStatus(id);\n                        return; // stop handling this message\n                    }\n                    if (payload.reportUrl) {\n                        setReportUrl(String(payload.reportUrl));\n                        console.log('FRONTEND: Report URL set:', payload.reportUrl);\n                    }\n                    const fn = payload.function;\n                    const st = payload.status;\n                    if (fn && st) {\n                        setSteps((prev)=>prev.map((s)=>{\n                                if (s.fn !== fn) return s;\n                                const map = {\n                                    started: 'in-progress',\n                                    completed: 'completed',\n                                    error: 'error'\n                                };\n                                var _map_st;\n                                return {\n                                    ...s,\n                                    status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                                };\n                            }));\n                        if (fn === 'final_checking' && st === 'completed') {\n                            console.log('FRONTEND: Final Validation step completed.');\n                        }\n                    }\n                    if (fn === 'generate_pdf_report' && st === 'completed') {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process complete, closing SSE.');\n                        closeStream();\n                    }\n                    if (st === 'error') {\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Process error detected.');\n                    }\n                } catch (e) {\n                // keep-alives or non-JSON; ignore\n                }\n            };\n            es.onerror = (error)=>{\n                console.error('FRONTEND: SSE Error occurred:', error);\n                if (!cancelledRef.current && id) {\n                    pollStatus(id);\n                }\n            };\n        });\n    }\n    async function pollStatus(id) {\n        if (cancelledRef.current || isComplete) return;\n        try {\n            const res = await fetch(\"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.ORCHESTRATOR_STATUS_URL, \"?jobId=\").concat(encodeURIComponent(id)), {\n                cache: 'no-store'\n            });\n            if (res.ok) {\n                const data = await res.json();\n                if (data.reportUrl) setReportUrl(data.reportUrl);\n                if (data.steps) {\n                    setSteps((prev)=>prev.map((s)=>{\n                            const st = data.steps[s.fn];\n                            const map = {\n                                pending: 'pending',\n                                in_progress: 'in-progress',\n                                completed: 'completed',\n                                error: 'error'\n                            };\n                            var _map_st;\n                            return st ? {\n                                ...s,\n                                status: (_map_st = map[st]) !== null && _map_st !== void 0 ? _map_st : s.status\n                            } : s;\n                        }));\n                    const done = data.steps['generate_pdf_report'] === 'completed';\n                    if (done) {\n                        setIsComplete(true);\n                        setIsProcessing(false);\n                        console.log('FRONTEND: Polling detected process complete.');\n                        return;\n                    }\n                    if (data.steps['final_checking'] === 'completed') {\n                        console.log('FRONTEND: Final Validation step completed (via polling).');\n                    }\n                }\n            }\n        } catch (pollError) {\n            console.error('FRONTEND: Error during polling:', pollError);\n        }\n        setTimeout(()=>pollStatus(id), 1000);\n    }\n    async function startFromPdf(file) {\n        resetUI();\n        try {\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            console.log('FRONTEND: Starting PDF upload...');\n            await uploadPdf(file);\n            console.log('FRONTEND: PDF upload complete.');\n            await startOrchestratorPipeline(currentJobId, 'pdf', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromPdf workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function startFromStored() {\n        resetUI();\n        try {\n            const currentJobId = await initOrchestratorJob();\n            console.log('FRONTEND: Opening SSE (with polling fallback)...');\n            await openEventStream(currentJobId);\n            await startOrchestratorPipeline(currentJobId, 'stored', {\n                scrapeEnabled: true,\n                extractEnabled: true,\n                generatePdf: true,\n                retrainModels: false\n            });\n            pollStatus(currentJobId);\n        } catch (error) {\n            console.error('FRONTEND: Error in startFromStored workflow:', error);\n            setIsProcessing(false);\n            closeStream();\n        }\n    }\n    async function cancel() {\n        console.log('FRONTEND: Cancel requested for jobId:', jobId);\n        cancelledRef.current = true;\n        closeStream();\n        setIsProcessing(false);\n        setSteps(_constants__WEBPACK_IMPORTED_MODULE_1__.INITIAL_STEPS.map((s)=>({\n                ...s,\n                status: 'pending'\n            })));\n        if (jobId) {\n            try {\n                const url = \"\".concat(_constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE, \"/api/orchestrator/cancel\");\n                const res = await fetch(url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        jobId\n                    })\n                });\n                if (!res.ok) {\n                    const txt = await res.text().catch(()=>'');\n                    throw new Error(txt || 'Cancel request failed');\n                }\n                console.log('FRONTEND: Cancel request sent to backend.');\n            } catch (cancelError) {\n                console.error('FRONTEND: Error sending cancel request:', cancelError);\n            }\n        }\n    }\n    return {\n        steps,\n        isProcessing,\n        isComplete,\n        reportUrl,\n        jobId,\n        startFromPdf,\n        startFromStored,\n        cancel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JlcG9ydC91c2VPcmNoZXN0cmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHFCQUFxQjtxRUFHK0I7QUFTL0I7QUFVckIsU0FBU1UsTUFBTUMsRUFBVTtJQUN2QixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsSUFBTUMsV0FBV0QsR0FBR0Y7QUFDMUM7QUFFQSxTQUFTSSxjQUFjQyxHQUFXO0lBQ2hDLElBQUk7UUFDRixPQUFPLElBQUlDLElBQUlELEtBQUtFLFFBQVE7SUFDOUIsRUFBRSxVQUFNO1lBQ09UO1FBQWIsTUFBTVUsT0FBT1YsQ0FBQUEsb0JBQUFBLGdEQUFRQSxhQUFSQSxnREFBUUEsdUJBQVJBLGdEQUFRQSxDQUFFVyxPQUFPLENBQUMsUUFBUSxpQkFBMUJYLCtCQUFBQSxvQkFBaUM7UUFDOUMsTUFBTVksT0FBT0wsSUFBSU0sVUFBVSxDQUFDLE9BQU9OLE1BQU0sSUFBUSxPQUFKQTtRQUM3QyxPQUFPLEdBQVVLLE9BQVBGLE1BQVksT0FBTEU7SUFDbkI7QUFDRjtBQUVBLDZFQUE2RSxHQUM3RSxlQUFlRSxtQkFBbUJQLEdBQVc7UUFBRVEsUUFBQUEsaUVBQVEsSUFBSUMsVUFBQUEsaUVBQVU7SUFDbkUsTUFBTUMsTUFBTVgsY0FBY0M7SUFDMUIsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUlILE9BQU9HLElBQUs7UUFDOUIsTUFBTUMsT0FBTyxNQUFvQkQsT0FBZEUsS0FBS0MsR0FBRyxJQUFHLEtBQUssT0FBRkg7UUFDakMsTUFBTUksTUFBTUwsSUFBSU0sUUFBUSxDQUFDLE9BQU8sTUFBTTtRQUN0QyxNQUFNQyxXQUFXLEdBQVNGLE9BQU5MLEtBQVlFLE9BQU5HLEtBQVcsT0FBTEg7UUFDaEMsSUFBSTtZQUNGLElBQUlNLE1BQU0sTUFBTUMsTUFBTUYsVUFBVTtnQkFBRUcsUUFBUTtnQkFBUUMsT0FBTztZQUFXO1lBQ3BFLElBQUlILElBQUlJLEVBQUUsRUFBRSxPQUFP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ZW1FO1FBQ2I3RCxRQUFRYyxHQUFHLENBQUMseUNBQXlDMUI7UUFDckRHLGFBQWFJLE9BQU8sR0FBRztRQUN2QkQ7UUFDQVgsZ0JBQWdCO1FBQ2hCRixTQUFTdkQscURBQWFBLENBQUM2RSxHQUFHLENBQUMsQ0FBQ0MsSUFBTztnQkFBRSxHQUFHQSxDQUFDO2dCQUFFMUMsUUFBUTtZQUFVO1FBRTdELElBQUkwQixPQUFPO1lBQ1QsSUFBSTtnQkFDRixNQUFNakQsTUFBTSxHQUFZLE9BQVRQLGdEQUFRQSxFQUFDO2dCQUN4QixNQUFNeUIsTUFBTSxNQUFNQyxNQUFNbkIsS0FBSztvQkFDM0JvQixRQUFRO29CQUNSd0QsU0FBUzt3QkFBRSxnQkFBZ0I7b0JBQW1CO29CQUM5Q3pDLE1BQU0wQyxLQUFLQyxTQUFTLENBQUM7d0JBQUU3QjtvQkFBTTtnQkFDL0I7Z0JBQ0EsSUFBSSxDQUFDL0IsSUFBSUksRUFBRSxFQUFFO29CQUNYLE1BQU1pRCxNQUFNLE1BQU1yRCxJQUFJc0QsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTTtvQkFDekMsTUFBTSxJQUFJL0MsTUFBTTZDLE9BQU87Z0JBQ3pCO2dCQUNBVixRQUFRYyxHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU9nRCxhQUFhO2dCQUNwQjlELFFBQVFDLEtBQUssQ0FBQywyQ0FBMkM2RDtZQUMzRDtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xsRjtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBc0U7UUFDQUU7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc3RhbC9Eb2N1bWVudHMvUHJvamVjdHMvY3VycmljYWxpZ24vZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvcmVwb3J0L3VzZU9yY2hlc3RyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1c2VPcmNoZXN0cmF0b3IudHNcbid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgSU5JVElBTF9TVEVQUyxcbiAgT1JDSEVTVFJBVE9SX0VWRU5UU19VUkwsXG4gIE9SQ0hFU1RSQVRPUl9JTklUX1VSTCxcbiAgT1JDSEVTVFJBVE9SX1NUQVJUX1BJUEVMSU5FX1VSTCxcbiAgT1JDSEVTVFJBVE9SX1NUQVRVU19VUkwsXG4gIFBERl9VUExPQURfVVJMLFxuICBBUElfQkFTRSxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUgeyBPcmNoZXN0cmF0b3JTb3VyY2UsIFByb2Nlc3NTdGVwLCBTdGVwU3RhdHVzIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgUnVuRmxhZ3MgPSB7XG4gIHNjcmFwZUVuYWJsZWQ/OiBib29sZWFuO1xuICBleHRyYWN0RW5hYmxlZD86IGJvb2xlYW47XG4gIHJldHJhaW5Nb2RlbHM/OiBib29sZWFuO1xuICBnZW5lcmF0ZVBkZj86IGJvb2xlYW47XG59O1xuXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBtcykpO1xufVxuXG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpLnRvU3RyaW5nKCk7XG4gIH0gY2F0Y2gge1xuICAgIGNvbnN0IGJhc2UgPSBBUElfQkFTRT8ucmVwbGFjZSgvXFwvKyQvLCAnJykgPz8gJyc7XG4gICAgY29uc3QgcGF0aCA9IHVybC5zdGFydHNXaXRoKCcvJykgPyB1cmwgOiBgLyR7dXJsfWA7XG4gICAgcmV0dXJuIGAke2Jhc2V9JHtwYXRofWA7XG4gIH1cbn1cblxuLyoqIFByb2JlIFVSTCB1bnRpbCBpdCByZXNwb25kcyBPSy4gVHJpZXMgSEVBRCwgZmFsbHMgYmFjayB0byBHRVQgaWYgbmVlZGVkLiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsUmVhY2hhYmxlKHVybDogc3RyaW5nLCB0cmllcyA9IDEwLCBkZWxheU1zID0gNTAwKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGFicyA9IHRvQWJzb2x1dGVVcmwodXJsKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmllczsgaSsrKSB7XG4gICAgY29uc3QgYnVzdCA9IGBfdD0ke0RhdGUubm93KCl9LSR7aX1gO1xuICAgIGNvbnN0IHNlcCA9IGFicy5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICAgIGNvbnN0IHByb2JlVXJsID0gYCR7YWJzfSR7c2VwfSR7YnVzdH1gO1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzID0gYXdhaXQgZmV0Y2gocHJvYmVVcmwsIHsgbWV0aG9kOiAnSEVBRCcsIGNhY2hlOiAnbm8tc3RvcmUnIH0pO1xuICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDUgfHwgcmVzLnN0YXR1cyA9PT0gNTAxKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHByb2JlVXJsLCB7IG1ldGhvZDogJ0dFVCcsIGNhY2hlOiAnbm8tc3RvcmUnIH0pO1xuICAgICAgICBpZiAocmVzLm9rKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGlnbm9yZSBhbmQgcmV0cnlcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAoZGVsYXlNcyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogRG93bmxvYWQgYSBVUkwgYXMgYSBmaWxlIHdpdGhvdXQgcGFnZSBuYXZpZ2F0aW9uLiAqL1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRVcmxBc0ZpbGUodXJsOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgYWJzID0gdG9BYnNvbHV0ZVVybCh1cmwpO1xuICBjb25zdCBidXN0ID0gYWJzLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke2Fic30ke2J1c3R9X2RsPSR7RGF0ZS5ub3coKX1gLCB7IGNhY2hlOiAnbm8tc3RvcmUnIH0pO1xuICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKGBEb3dubG9hZCBmYWlsZWQ6ICR7cmVzLnN0YXR1c31gKTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcy5ibG9iKCk7XG4gIGNvbnN0IG9iamVjdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGEuaHJlZiA9IG9iamVjdFVybDtcbiAgYS5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICBhLmNsaWNrKCk7XG4gIGEucmVtb3ZlKCk7XG4gIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9yY2hlc3RyYXRvcigpIHtcbiAgY29uc3QgW3N0ZXBzLCBzZXRTdGVwc10gPSB1c2VTdGF0ZTxQcm9jZXNzU3RlcFtdPihJTklUSUFMX1NURVBTKTtcbiAgY29uc3QgW2lzUHJvY2Vzc2luZywgc2V0SXNQcm9jZXNzaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ29tcGxldGUsIHNldElzQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVwb3J0VXJsLCBzZXRSZXBvcnRVcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtqb2JJZCwgc2V0Sm9iSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXNSZWYgPSB1c2VSZWY8RXZlbnRTb3VyY2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FuY2VsbGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgb3BlbmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZG93bmxvYWRTdGFydGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBjbG9zZVN0cmVhbSA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZXNSZWYuY3VycmVudD8uY2xvc2UoKTtcbiAgICB9IGNhdGNoIHt9XG4gICAgZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgb3BlbmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBjbG9zZVN0cmVhbSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuXG4gIC8vIEF1dG8tZG93bmxvYWQgd2hlbiByZXBvcnRVcmwgYXJyaXZlcyDigJQgV0lUSE9VVCBuYXZpZ2F0aW5nXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghcmVwb3J0VXJsIHx8IGRvd25sb2FkU3RhcnRlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBkb3dubG9hZFN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWFjaGFibGUgPSBhd2FpdCB3YWl0VW50aWxSZWFjaGFibGUocmVwb3J0VXJsLCAxNCwgNTAwKTtcbiAgICAgICAgaWYgKCFyZWFjaGFibGUpIHRocm93IG5ldyBFcnJvcignUmVwb3J0IFVSTCBpcyBub3QgcmVhY2hhYmxlIHlldCcpO1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWQgPSBgYWxpZ25tZW50X3JlcG9ydF8ke2pvYklkID8/IERhdGUubm93KCl9LnBkZmA7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkVXJsQXNGaWxlKHJlcG9ydFVybCwgc3VnZ2VzdGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogQXV0by1kb3dubG9hZCBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgZG93bmxvYWRTdGFydGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3JlcG9ydFVybCwgam9iSWRdKTtcblxuICBjb25zdCByZXNldFVJID0gKCkgPT4ge1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcbiAgICBzZXRJc0NvbXBsZXRlKGZhbHNlKTtcbiAgICBzZXRSZXBvcnRVcmwobnVsbCk7XG4gICAgc2V0U3RlcHMoSU5JVElBTF9TVEVQUy5tYXAoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ3BlbmRpbmcnIH0pKSk7XG4gICAgY2FuY2VsbGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBkb3dubG9hZFN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBkZihmaWxlOiBGaWxlKSB7XG4gICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm0uYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goUERGX1VQTE9BRF9VUkwsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IGZvcm0gfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IHR4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHR4dCB8fCAnRmFpbGVkIHRvIHVwbG9hZCBQREYnKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBpbml0T3JjaGVzdHJhdG9ySm9iKCkge1xuICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUmVxdWVzdGluZyBuZXcgam9iSWQgZnJvbSBiYWNrZW5kLi4uJyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goT1JDSEVTVFJBVE9SX0lOSVRfVVJMLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe30pLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCB0eHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+ICcnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eHQgfHwgJ0ZhaWxlZCB0byBpbml0aWFsaXplIG9yY2hlc3RyYXRvciBqb2InKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgaWYgKGRhdGE/LmpvYklkKSB7XG4gICAgICBzZXRKb2JJZChTdHJpbmcoZGF0YS5qb2JJZCkpO1xuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBSZWNlaXZlZCBqb2JJZDonLCBkYXRhLmpvYklkKTtcbiAgICAgIHJldHVybiBkYXRhLmpvYklkIGFzIHN0cmluZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBqb2JJZCByZWNlaXZlZCBmcm9tIGluaXQgZW5kcG9pbnQnKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0T3JjaGVzdHJhdG9yUGlwZWxpbmUoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBzb3VyY2U6IE9yY2hlc3RyYXRvclNvdXJjZSxcbiAgICBmbGFnczogUnVuRmxhZ3MgPSB7fVxuICApIHtcbiAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFJlcXVlc3RpbmcgYmFja2VuZCB0byBTVEFSVCBwaXBlbGluZSBmb3Igam9iSWQ6JywgaWQpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBzb3VyY2UsXG4gICAgICBzY3JhcGVFbmFibGVkOiBmbGFncy5zY3JhcGVFbmFibGVkID8/IHRydWUsXG4gICAgICBleHRyYWN0RW5hYmxlZDogZmxhZ3MuZXh0cmFjdEVuYWJsZWQgPz8gdHJ1ZSxcbiAgICAgIHJldHJhaW5Nb2RlbHM6IGZsYWdzLnJldHJhaW5Nb2RlbHMgPz8gZmFsc2UsXG4gICAgICBnZW5lcmF0ZVBkZjogZmxhZ3MuZ2VuZXJhdGVQZGYgPz8gdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7T1JDSEVTVFJBVE9SX1NUQVJUX1BJUEVMSU5FX1VSTH0vJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHh0IHx8IGBGYWlsZWQgdG8gc3RhcnQgcGlwZWxpbmUgZm9yIGpvYklkICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogQmFja2VuZCBhY2tub3dsZWRnZWQgcGlwZWxpbmUgc3RhcnQgZm9yIGpvYklkOicsIGlkKTtcbiAgfVxuXG4gIC8qKiBPcGVucyBTU0UuIFJlc29sdmVzIG9uY2Ugb3BlbmVkIE9SIGFmdGVyIGEgc2hvcnQgZ3JhY2UgcGVyaW9kIHNvIHdlIGNhbiBmYWxsYmFjayB0byBwb2xsaW5nLiAqL1xuICBmdW5jdGlvbiBvcGVuRXZlbnRTdHJlYW0oaWQ/OiBzdHJpbmcgfCBudWxsLCBncmFjZU1zID0gMTIwMCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogQ2Fubm90IG9wZW4gRXZlbnRTb3VyY2UsIGpvYklkIGlzIG51bGwuJyk7XG4gICAgICAgIHJlc29sdmUoKTsgLy8gbGV0IHBvbGxpbmcgaGFuZGxlIGl0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xvc2VTdHJlYW0oKTtcblxuICAgICAgY29uc3QgdXJsID0gYCR7T1JDSEVTVFJBVE9SX0VWRU5UU19VUkx9P2pvYklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gO1xuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBBdHRlbXB0aW5nIHRvIG9wZW4gRXZlbnRTb3VyY2UgdG86JywgdXJsKTtcbiAgICAgIGNvbnN0IGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgICBlc1JlZi5jdXJyZW50ID0gZXM7XG5cbiAgICAgIGNvbnN0IGdyYWNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFvcGVuZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRlJPTlRFTkQ6IFNTRSBkaWQgbm90IG9wZW4gd2l0aGluIGdyYWNlIHBlcmlvZDsgY29udGludWluZyB3aXRoIHBvbGxpbmcgZmFsbGJhY2suJyk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBncmFjZU1zKTtcblxuICAgICAgZXMub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBvcGVuZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogU1NFIGNvbm5lY3Rpb24gb3BlbmVkIHN1Y2Nlc3NmdWxseSBmb3Igam9iSWQ6JywgaWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQoZ3JhY2VUaW1lcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGVzLm9ubWVzc2FnZSA9IChldnQpID0+IHtcbiAgICAgICAgaWYgKCFldnQuZGF0YSkgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2dC5kYXRhKTtcblxuICAgICAgICAgIC8vIC0tLSBIYW5kbGUgZXhwbGljaXQgcGlwZWxpbmUgZXJyb3IgZXZlbnRzIC0tLVxuICAgICAgICAgIGlmIChwYXlsb2FkPy50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQSVBFTElORSBFUlJPUjonLCBwYXlsb2FkLmZhaWxlZF9hdCB8fCBwYXlsb2FkLmZ1bmN0aW9uLCBwYXlsb2FkLmVycm9yKTtcbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIGZhaWxlZCBzdGVwIGFzIGVycm9yIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBjb25zdCBmYWlsZWRGbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGF5bG9hZC5mYWlsZWRfYXQgfHwgcGF5bG9hZC5mdW5jdGlvbjtcbiAgICAgICAgICAgIGlmIChmYWlsZWRGbikge1xuICAgICAgICAgICAgICBzZXRTdGVwcygocHJldikgPT5cbiAgICAgICAgICAgICAgICBwcmV2Lm1hcCgocykgPT4gKHMuZm4gPT09IGZhaWxlZEZuID8geyAuLi5zLCBzdGF0dXM6ICdlcnJvcicgfSA6IHMpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbGxlZFJlZi5jdXJyZW50ICYmIGlkKSBwb2xsU3RhdHVzKGlkKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc3RvcCBoYW5kbGluZyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF5bG9hZC5yZXBvcnRVcmwpIHtcbiAgICAgICAgICAgIHNldFJlcG9ydFVybChTdHJpbmcocGF5bG9hZC5yZXBvcnRVcmwpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUmVwb3J0IFVSTCBzZXQ6JywgcGF5bG9hZC5yZXBvcnRVcmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZuOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBwYXlsb2FkLmZ1bmN0aW9uO1xuICAgICAgICAgIGNvbnN0IHN0OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBwYXlsb2FkLnN0YXR1cztcblxuICAgICAgICAgIGlmIChmbiAmJiBzdCkge1xuICAgICAgICAgICAgc2V0U3RlcHMoKHByZXYpID0+XG4gICAgICAgICAgICAgIHByZXYubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHMuZm4gIT09IGZuKSByZXR1cm4gcztcbiAgICAgICAgICAgICAgICBjb25zdCBtYXA6IFJlY29yZDxzdHJpbmcsIFN0ZXBTdGF0dXM+ID0ge1xuICAgICAgICAgICAgICAgICAgc3RhcnRlZDogJ2luLXByb2dyZXNzJyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnMsIHN0YXR1czogbWFwW3N0XSA/PyBzLnN0YXR1cyB9O1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGZuID09PSAnZmluYWxfY2hlY2tpbmcnICYmIHN0ID09PSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IEZpbmFsIFZhbGlkYXRpb24gc3RlcCBjb21wbGV0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZuID09PSAnZ2VuZXJhdGVfcGRmX3JlcG9ydCcgJiYgc3QgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICBzZXRJc0NvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUHJvY2VzcyBjb21wbGV0ZSwgY2xvc2luZyBTU0UuJyk7XG4gICAgICAgICAgICBjbG9zZVN0cmVhbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3QgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFByb2Nlc3MgZXJyb3IgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlcyBvciBub24tSlNPTjsgaWdub3JlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGVzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRlJPTlRFTkQ6IFNTRSBFcnJvciBvY2N1cnJlZDonLCBlcnJvcik7XG4gICAgICAgIGlmICghY2FuY2VsbGVkUmVmLmN1cnJlbnQgJiYgaWQpIHtcbiAgICAgICAgICBwb2xsU3RhdHVzKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHBvbGxTdGF0dXMoaWQ6IHN0cmluZykge1xuICAgIGlmIChjYW5jZWxsZWRSZWYuY3VycmVudCB8fCBpc0NvbXBsZXRlKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke09SQ0hFU1RSQVRPUl9TVEFUVVNfVVJMfT9qb2JJZD0ke2VuY29kZVVSSUNvbXBvbmVudChpZCl9YCwge1xuICAgICAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlcy5qc29uKCkpIGFzIHtcbiAgICAgICAgICBzdGVwcz86IFJlY29yZDwncGVuZGluZycgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InIHwgc3RyaW5nLCBhbnk+O1xuICAgICAgICAgIHJlcG9ydFVybD86IHN0cmluZztcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGF0YS5yZXBvcnRVcmwpIHNldFJlcG9ydFVybChkYXRhLnJlcG9ydFVybCk7XG5cbiAgICAgICAgaWYgKGRhdGEuc3RlcHMpIHtcbiAgICAgICAgICBzZXRTdGVwcygocHJldikgPT5cbiAgICAgICAgICAgIHByZXYubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0ID0gZGF0YS5zdGVwcyFbcy5mbl07XG4gICAgICAgICAgICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZywgU3RlcFN0YXR1cz4gPSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZzogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgICAgIGluX3Byb2dyZXNzOiAnaW4tcHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdlcnJvcicsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBzdCA/IHsgLi4ucywgc3RhdHVzOiBtYXBbc3RdID8/IHMuc3RhdHVzIH0gOiBzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgZG9uZSA9IGRhdGEuc3RlcHNbJ2dlbmVyYXRlX3BkZl9yZXBvcnQnXSA9PT0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNldElzQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBQb2xsaW5nIGRldGVjdGVkIHByb2Nlc3MgY29tcGxldGUuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRhdGEuc3RlcHNbJ2ZpbmFsX2NoZWNraW5nJ10gPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IEZpbmFsIFZhbGlkYXRpb24gc3RlcCBjb21wbGV0ZWQgKHZpYSBwb2xsaW5nKS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChwb2xsRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZST05URU5EOiBFcnJvciBkdXJpbmcgcG9sbGluZzonLCBwb2xsRXJyb3IpO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHBvbGxTdGF0dXMoaWQpLCAxMDAwKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RnJvbVBkZihmaWxlOiBGaWxlKSB7XG4gICAgcmVzZXRVSSgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Sm9iSWQgPSBhd2FpdCBpbml0T3JjaGVzdHJhdG9ySm9iKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogT3BlbmluZyBTU0UgKHdpdGggcG9sbGluZyBmYWxsYmFjaykuLi4nKTtcbiAgICAgIGF3YWl0IG9wZW5FdmVudFN0cmVhbShjdXJyZW50Sm9iSWQpO1xuXG4gICAgICBjb25zb2xlLmxvZygnRlJPTlRFTkQ6IFN0YXJ0aW5nIFBERiB1cGxvYWQuLi4nKTtcbiAgICAgIGF3YWl0IHVwbG9hZFBkZihmaWxlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGUk9OVEVORDogUERGIHVwbG9hZCBjb21wbGV0ZS4nKTtcblxuICAgICAgYXdhaXQgc3RhcnRPcmNoZXN0cmF0b3JQaXBlbGluZShjdXJyZW50Sm9iSWQsICdwZGYnLCB7XG4gICAgICAgIHNjcmFwZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGV4dHJhY3RFbmFibGVkOiB0cnVlLFxuICAgICAgICBnZW5lcmF0ZVBkZjogdHJ1ZSxcbiAgICAgICAgcmV0cmFpbk1vZGVsczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgcG9sbFN0YXR1cyhjdXJyZW50Sm9iSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogRXJyb3IgaW4gc3RhcnRGcm9tUGRmIHdvcmtmbG93OicsIGVycm9yKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICBjbG9zZVN0cmVhbSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RnJvbVN0b3JlZCgpIHtcbiAgICByZXNldFVJKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRKb2JJZCA9IGF3YWl0IGluaXRPcmNoZXN0cmF0b3JKb2IoKTtcblxuICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBPcGVuaW5nIFNTRSAod2l0aCBwb2xsaW5nIGZhbGxiYWNrKS4uLicpO1xuICAgICAgYXdhaXQgb3BlbkV2ZW50U3RyZWFtKGN1cnJlbnRKb2JJZCk7XG5cbiAgICAgIGF3YWl0IHN0YXJ0T3JjaGVzdHJhdG9yUGlwZWxpbmUoY3VycmVudEpvYklkLCAnc3RvcmVkJywge1xuICAgICAgICBzY3JhcGVFbmFibGVkOiB0cnVlLFxuICAgICAgICBleHRyYWN0RW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZ2VuZXJhdGVQZGY6IHRydWUsXG4gICAgICAgIHJldHJhaW5Nb2RlbHM6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIHBvbGxTdGF0dXMoY3VycmVudEpvYklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRlJPTlRFTkQ6IEVycm9yIGluIHN0YXJ0RnJvbVN0b3JlZCB3b3JrZmxvdzonLCBlcnJvcik7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgY2xvc2VTdHJlYW0oKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBDYW5jZWwgcmVxdWVzdGVkIGZvciBqb2JJZDonLCBqb2JJZCk7XG4gICAgY2FuY2VsbGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIGNsb3NlU3RyZWFtKCk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICBzZXRTdGVwcyhJTklUSUFMX1NURVBTLm1hcCgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGVuZGluZycgfSkpKTtcblxuICAgIGlmIChqb2JJZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0V9L2FwaS9vcmNoZXN0cmF0b3IvY2FuY2VsYDtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBqb2JJZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR4dCB8fCAnQ2FuY2VsIHJlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0ZST05URU5EOiBDYW5jZWwgcmVxdWVzdCBzZW50IHRvIGJhY2tlbmQuJyk7XG4gICAgICB9IGNhdGNoIChjYW5jZWxFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGUk9OVEVORDogRXJyb3Igc2VuZGluZyBjYW5jZWwgcmVxdWVzdDonLCBjYW5jZWxFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGVwcyxcbiAgICBpc1Byb2Nlc3NpbmcsXG4gICAgaXNDb21wbGV0ZSxcbiAgICByZXBvcnRVcmwsXG4gICAgam9iSWQsXG4gICAgc3RhcnRGcm9tUGRmLFxuICAgIHN0YXJ0RnJvbVN0b3JlZCxcbiAgICBjYW5jZWwsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJJTklUSUFMX1NURVBTIiwiT1JDSEVTVFJBVE9SX0VWRU5UU19VUkwiLCJPUkNIRVNUUkFUT1JfSU5JVF9VUkwiLCJPUkNIRVNUUkFUT1JfU1RBUlRfUElQRUxJTkVfVVJMIiwiT1JDSEVTVFJBVE9SX1NUQVRVU19VUkwiLCJQREZfVVBMT0FEX1VSTCIsIkFQSV9CQVNFIiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInRvQWJzb2x1dGVVcmwiLCJ1cmwiLCJVUkwiLCJ0b1N0cmluZyIsImJhc2UiLCJyZXBsYWNlIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJ3YWl0VW50aWxSZWFjaGFibGUiLCJ0cmllcyIsImRlbGF5TXMiLCJhYnMiLCJpIiwiYnVzdCIsIkRhdGUiLCJub3ciLCJzZXAiLCJpbmNsdWRlcyIsInByb2JlVXJsIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsIm9rIiwic3RhdHVzIiwiZG93bmxvYWRVcmxBc0ZpbGUiLCJmaWxlbmFtZSIsIkVycm9yIiwiYmxvYiIsIm9iamVjdFVybCIsImNyZWF0ZU9iamVjdFVSTCIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZSIsInJldm9rZU9iamVjdFVSTCIsInVzZU9yY2hlc3RyYXRvciIsInN0ZXBzIiwic2V0U3RlcHMiLCJpc1Byb2Nlc3NpbmciLCJzZXRJc1Byb2Nlc3NpbmciLCJpc0NvbXBsZXRlIiwic2V0SXNDb21wbGV0ZSIsInJlcG9ydFVybCIsInNldFJlcG9ydFVybCIsImpvYklkIiwic2V0Sm9iSWQiLCJlc1JlZiIsImNhbmNlbGxlZFJlZiIsIm9wZW5lZFJlZiIsImRvd25sb2FkU3RhcnRlZFJlZiIsImNsb3NlU3RyZWFtIiwiY3VycmVudCIsImNsb3NlIiwicmVhY2hhYmxlIiwic3VnZ2VzdGVkIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwicmVzZXRVSSIsIm1hcCIsInMiLCJ1cGxvYWRQZGYiLCJmaWxlIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwidHh0IiwidGV4dCIsImNhdGNoIiwiaW5pdE9yY2hlc3RyYXRvckpvYiIsImxvZyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImpzb24iLCJTdHJpbmciLCJzdGFydE9yY2hlc3RyYXRvclBpcGVsaW5lIiwiaWQiLCJzb3VyY2UiLCJmbGFncyIsInBheWxvYWQiLCJzY3JhcGVFbmFibGVkIiwiZXh0cmFjdEVuYWJsZWQiLCJyZXRyYWluTW9kZWxzIiwiZ2VuZXJhdGVQZGYiLCJlbmNvZGVVUklDb21wb25lbnQiLCJvcGVuRXZlbnRTdHJlYW0iLCJncmFjZU1zIiwicmVzb2x2ZSIsImVzIiwiRXZlbnRTb3VyY2UiLCJncmFjZVRpbWVyIiwid2FybiIsIm9ub3BlbiIsImNsZWFyVGltZW91dCIsIm9ubWVzc2FnZSIsImV2dCIsInBhcnNlIiwidHlwZSIsImZhaWxlZF9hdCIsImZ1bmN0aW9uIiwiZmFpbGVkRm4iLCJwcmV2IiwiZm4iLCJwb2xsU3RhdHVzIiwic3QiLCJzdGFydGVkIiwiY29tcGxldGVkIiwib25lcnJvciIsInBlbmRpbmciLCJpbl9wcm9ncmVzcyIsImRvbmUiLCJwb2xsRXJyb3IiLCJzdGFydEZyb21QZGYiLCJjdXJyZW50Sm9iSWQiLCJzdGFydEZyb21TdG9yZWQiLCJjYW5jZWwiLCJjYW5jZWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/report/useOrchestrator.ts\n"));

/***/ })

});